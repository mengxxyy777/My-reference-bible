# 只用递归实现栈的逆序

​	我们可以利用栈本身可以保存这一层状态的这一特性，来做栈的逆序。

​	每层递归保存当前的值，如果栈空了，开始放回即可。

## 过程细化

​	每次保存一个值，这个值是当前栈底元素，且是递归获取，所以push的过程实际上是按取出顺序倒序压入，从而实现逆序。

​	给出栈：s[1, 2, 3, 4, 5]，如下所示：

<img src="C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241116214916610.png" alt="image-20241116214916610" style="zoom: 50%;" />

​	每次需要获取栈底元素并移除，返回给逆序函数，所以返回给逆序函数的顺序依次为：1, 2, 3, 4, 5。

​	而逆序函数也是递归调用的，所以压入栈的顺序其实应该为5, 4, 3, 2, 1。故而实现逆序。

## 逆序函数

​	给定一个栈，获得的元素利用递归本身特性保存下来，待到最后一层往回压入，代码如下：

```cpp
void reversestack(stack<int>& s)
{
	if (s.empty())
	{
		return ;
	}
	int num = bottomout(s);
	reversestack(s);
	s.push(num);
}
```

## 获取栈底元素并删除的函数

​	从栈顶开始，每次保存当前值并向下沉直到栈底，返回的过程中除了栈底元素都重新压入即可。

```cpp
// 返回栈底元素，并移除，上面的元素依次下沉
int bottomout(stack<int>& s)
{
	int ans = s.top();
	s.pop();
	if (s.empty())
	{
		return ans;
	}
	int last = bottomout(s);
	s.push(ans);
	return last;
}
```

## 整体code

```cpp
#include <iostream>
#include <stack>
using namespace std;

// 返回栈底元素，并移除，上面的元素依次下沉
int bottomout(stack<int>& s)
{
	int ans = s.top();
	s.pop();
	if (s.empty())
	{
		return ans;
	}
	int last = bottomout(s);
	s.push(ans);
	return last;
}

void reversestack(stack<int>& s)
{
	if (s.empty())
	{
		return ;
	}
	int num = bottomout(s);
	reversestack(s);
	s.push(num);
}

int main()
{
	stack<int> s;
	s.push(1);
	s.push(2);
	s.push(3);
	s.push(4);
	s.push(5);

	reversestack(s);

	while (!s.empty())
	{
		cout << s.top() << " ";
		s.pop();
	}

	return 0;
}
```

