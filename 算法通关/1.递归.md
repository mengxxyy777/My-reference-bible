# 递归

## 何为递归？

​	递归是一种自己调用自己的行为。

​	具体一点说，就是当处理大问题时，发现需要同样的规则求出稍小问题的解，才能求出大问题的解，这样不断地向下传递，一直到某一个边界，或者说小问题已经不能再继续向下分解为止。

## 例题

​	给定一个n个元素的数组a，求出该数组的最大值。

​	（*这里给出递归解法，初步理解什么是递归*）

​	思路：大问题是整个数组的最大值，那么我们分解成小问题，是否可以将数组根据中点分割为两份，先求前面的最大值，再求后面的最大值呢？答案是可以的，因为前半部分的最大值和后半部分的最大值，二者较大的值即为整个数组的最大值。那么这两部分的最大值怎么求呢？一样的过程，划分、整合，返回结果。例如，大小为5的数组的求解如下：

![whiteboard_exported_image](C:\Users\hp\Downloads\whiteboard_exported_image.png)

​	我们发现，递归进行到左右边界相同时，就不能继续向下分解了，这个时候需要返回我们的结果了。

​	一开始，从下标0到下标4，找最大值，等同于找[0, 2]上的最大值和[3, 4]上的最大值，二者大者返回；下标[0, 2]上的最大值等同于找[0, 1]上的最大值和[2, 2]上的最大值，二者大者返回。而[2, 2]上的最大值不就是a[2]本身吗？这个时候直接返回就行了。假如给出数组a：[4, 1, 5, 3, 6]，返回值过程如下：

![image-20241007215824869](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007215824869.png)

​	最终找到了[0, 4]上的最大值为6,。

​	相信这个过程很清晰明了了吧！代码也非常简单。

## code

```cpp
#include <iostream>
using namespace std;

int a[105];

// f函数的作用是求[l, r]上的最大值 
int f(int l, int r)
{
	// 如果左右边界相同，直接返回结果 
	if(l == r)
	{
		return a[l];
	}
  
	// 取中点 
	int mid = (l+r) / 2;
	
	// lmax记录左半部分的最大值 
	int lmax = f(l, mid);
	
	// rmax记录右半部分的最大值 
	int rmax = f(mid+1, r);
	
	// 将二者大的作为结果返回 
	return max(lmax, rmax);
}

int main()
{
	// 自行处理数据输入 
	int n;
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	// 最终结果保存在ans中 
	int ans = f(0, n-1);
	
	cout << ans;
	
	return 0;
}
```

​	这样我们就初步理解了递归的过程。

## 递归的核心本质

​	递归是如何做到的呢？

​	实际上是在每次调用子问题时，将目前正在执行的函数暂时保管起来，当前的区间边界、求得的结果、变量等都保存，在进入子问题的函数中，为什么要保存那么多的东西呢？因为子问题调用结束返回时，还要函数本身继续正常运行，听起来有点玄乎，实际上很好理解。上面的例子中，我们先计算了lmax，接下来在计算rmax时，进入该子问题之前，我们应该保持lmax的值不变，这样在rmax返回时我们才能确保答案的正确。

​	那么我们没有做多余的动作，比如开一个临时变量存储lmax的值等等，程序是怎么记住的呢？实际上当前函数是被压入系统栈当中，包括一些必须的变量，都要记录在系统栈中，这个动作我们有一个比较形象的词语称呼：保护现场。没错，必须要保护现场，才能保证答案的正确性。

​	我们再次深入上面的例子，理解这一过程：

​	首先，系统栈为空，当运行到第一个子问题时，需要将当前状态压入栈中，再去计算子问题：

![image-20241007222216432](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007222216432.png)

​	这个时候子问题逐层深入，直至左右边界相等：

![image-20241007222413169](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007222413169.png)

​	这个时候f(0, 0)应该返回结果a[0]，lmax的值作为[0, 1]左半部分的答案保存，f(0, 0)这个状态从系统栈弹出，并继续到f(1, 1)：

![image-20241007222604183](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007222604183.png)

​	f(1, 1)的值为a[1]，作为结果直接返回，也就是f(0, 1)的rmax：

![image-20241007222825594](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007222825594.png)

​	这个时候我们应该在f(0, 1)函数中，此时应返回lmax和rmax中的最大值作为f(0, 2)的lmax：

![image-20241007222956314](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241007222956314.png)

​	rmax的求解过程同上一样，直至系统栈为空，整个问题求解也就完毕了。

​	**初学者一定要画图帮助分析！！**

## 递归与非递归

​	**递归一定可以改成非递归**，无非就是不用系统栈，用内存空间呗。

​	系统栈较为脆弱，通常递归深度足够深的时候，就会报错了，俗称爆栈，通常递归都要改为非递归。

### 	哪些递归没必要改成非递归呢？

​	即使数据再大，递归的深度也不会很深。例如：归并排序、快速排序、线段树、很多平衡树等。

​	例如线段树，每次分一半，即使数据范围在2^64个，根据完全二叉树的性质可知，最大深度也就在64层左右，还会有提前弹出的过程，深度只少不多，这样的递归就不必改为非递归。

## master公式

​	master公式是用来快速计算递归的时间复杂度的公式，递归的形式需满足：T(N) = a*T(N/b) + O(n^c)。

​	使用master公式的前提是递归分解**子问题的规模必须相同**！

​	公式内容如下：

​		如果log(b,a) < c，复杂度为O(n^c)；

​		如果log(b,a) > c，复杂度为O(n^log(b,a))；

​		如果log(b,a) == c，复杂度为O(n^c * logn)；

​	特殊地：形如T(N) = 2*T(N/2) + O(n*logn)的递归，时间复杂度为O(n*(logn)^2)；

