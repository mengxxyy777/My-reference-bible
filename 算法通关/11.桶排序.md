# 桶排序

​	桶排序是一种基于技术的排序算法，其桶的思想是核心。

## 何为桶排序？

​	桶排序是将数组中某一类元素映射到一个桶中，然后将每个桶分别排序，最后将桶合并即可。基本的排序很简单，主要是桶的分类。

## 桶排序的过程

​	给定一个长度为6的数组，下标从0开始：[1, 4, 6, 3, 5, 2]。

​		我们每个桶大小设置为4，需要两个桶：[1, 3, 2]、[4, 6, 5]。

​		然后对每个桶进行排序：[1, 2, 3]、[4, 5, 6]。

​		最后将桶合并：[1, 2, 3, 4, 5, 6]。

​		排序完成。

​	过程很简单，代码也很简单。

## code

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
int a[105];
int index;

void bucketSort()
{
	// 准备好10个桶 
	vector< vector<int> > bucket(10);
	
	// 把数组中的每个数字映射到桶中，使得桶与桶整体上升序排列 
	for (int i = 0; i < n; i++)
	{
		bucket[(a[i] / 4)].push_back(a[i]);
	}
	
	// 对每个桶内部排好序 
	for (int i = 0; i < bucket.size(); i++)
	{
		sort(bucket[i].begin(), bucket[i].end());
	}
	
	// 一个一个从小到大取出来 
	for (int i = 0; i < bucket.size(); i++)
	{
		for (int j = 0; j < bucket[i].size(); j++)
		{
			a[index++] = bucket[i][j];
		}
	}
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}

	bucketSort();

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	**取决于每个桶内排序的时间复杂度**。

### 	空间复杂度

​	n个元素，最多需要n个桶，所以**空间复杂度为O(n)**。

## 小结

### 	稳定性

​	相同元素先进入桶，同时也被先取出，故桶排序具有稳定性。

### 	非原地排序

​	需要额外的桶空间。

### 	优点

​	可以做范围排序。

### 	缺点

​	不适合大规模数据排序，桶多还会浪费空间。