# 基数排序

​	基数排序也不是比较排序，而是利用了桶的思想，类似于前面的桶排序和基数排序，学习本课后会清除他们之间的联系。

## 何为基数排序？

​	从字面去记的话，就是基于数位的排序。它是从每个数字的个位开始，一直到所有数字的最高位，根据每一位的数字进行一次桶排序，再收回，最终得到的是一个有序数组。

## 基数排序过程

​	给定一个长度为6的数组，下标从0开始：[21, 214, 77, 23, 2157, 365]。

​		第一趟排序，根据个位数字进行桶排序，再收回，如图：

![image-20241012215029386](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241012215029386.png)

​		收回需要按顺序收回，目前的数组：[21, 23, 214, 365, 77, 2157]。

​		第二趟排序，按照十位数字，如图：

![image-20241012215338828](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241012215338828.png)

​		回收后的数组：[214, 21, 23, 2157, 365, 77]。

​		第三趟排序，按照百位数字，没有百位数字就认为是0：

![image-20241012215547451](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241012215547451.png)

​		回收后的数组：[21, 23, 77, 2157, 214, 365]。

​		最后一趟排序，按照千位数字：

![image-20241012215712668](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241012215712668.png)

​		回收后的数组：[21, 23, 77, 214, 365, 2157]。

​		我们发现数组就有序了。

​		代码实现跟桶排序差不多，过于简单，仅需要注意每次排序各个数位数字的获取，此处有个小技巧，在代码中会有体现，下方代码的桶排序实现较为巧妙，值得一看。

## code

```cpp
#include <iostream>
using namespace std;

int n;
int a[105];
int cnt[10]; // 记录每次排序对应位数的数字出现了几次，还要求前缀次数 
int help[105]; // 桶，记录每次排序后的结果 
int bits; //记录数组中数字的最大位数 

// 获取数字的位数 
int getbits(int num)
{
	int b = 0;
	while(num)
	{
		num /= 10;
		b++;
	}
	return b;
}

void radixsort()
{
	// offset用于每次获取对应数位的数字 
	int offset = 1;
	for(int nums = bits; nums > 0; nums--)
	{
		for(int i = 0; i < 10; i++)
		{
			cnt[i] = 0;
		}
		for(int i = 0; i < n; i++)
		{
			cnt[(a[i]/offset)%10]++;
		}
		for(int i = 1; i < 10; i++)
		{
			cnt[i] += cnt[i-1];
		}

		for(int i = n-1; i >= 0; i--)
		{
			help[--cnt[(a[i]/offset)%10]] = a[i];
		}
		
		for(int i = 0; i < n; i++)
		{
			a[i] = help[i];
		}
		
		offset *= 10;
	}
}

int main()
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> a[i];
		bits = max(bits, getbits(a[i]));
	}
	
	radixsort();
	
	for(int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}
	
	return 0;
} 
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	最外层循环进行d次，d是最大位数，每次需要O(n+r)的时间复杂度，所以总体**时间复杂度为O(d(n+r))**。

### 	空间复杂度

​	需要桶来辅助，还需要一个help数组，所以空间复杂度与桶的大小数量有关。

### 	优点

​	对于数字有特征的序列排序更加高效。

### 	缺点

​	需要额外的辅助空间，且只能处理非负整数。下面会介绍一下如何处理负数情况。

## 基数排序如何处理负数情况

​	我们在输入数组时，就可以记录一个最小值，然后将数组中所有的数字统一加上这个最小值的绝对值，使得整个序列非负化，然后再进行基数排序，排好序的数组再统一减去加上的值即可。

​	有一处细节需要注意，再每个数字都加上最小值的绝对值的时候，可能有些数字的位数会增加，因此需要加后统计最大位数。
