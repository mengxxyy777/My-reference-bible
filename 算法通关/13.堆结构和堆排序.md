# 堆结构和堆排序

*前置知识：完全二叉树*

​	堆排序是一种**比较排序**，过程比较好理解，但是代码对于一些新手朋友来说可能比较难写，但是不要着急，多去理解几遍，并且试着多默写几遍，很快就能体会到堆结构的奥妙了。

## 什么是堆？

​	堆在物理层面实际上是一个数组，来模拟一颗完全二叉树实现的。那么在这棵树顶，也就是数组下标为0的位置，是当前优先级最高的元素，我们希望马上处理该元素。当这个树顶元素，也就是优先级最高的元素处理完成后，通过调整堆将下一个优先级最高的元素放到堆顶，也叫**维护堆**。

​	这样操作下来，我们发现每次都处理优先级最高的，然后从堆里删除，再找次优先级，这个过程很像队列，队列的优先级实际上就是入队的时间戳，越早入队，优先级越高。所以堆的另外一个名字叫做**优先队列**。

## 大根堆和小根堆

​	所谓大根堆，就是把值最大的元素放在堆顶，每棵子树都维护这个性质。看一个例子：

![image-20241016120940446](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241016120940446.png)

​	该树即为堆，括号里标出的是对应在数组中的下标。

​	实际上堆只是一个数组，树的形状是我们想象出来的，利用的性质就是：

​		下标为i的结点，左儿子下标为2*i+1，右儿子下标为2*i+2，父结点下标为(i-1)/2。

## 堆插入

​	在已经建好的堆中插入一个元素，并且维护堆的性质，就是堆插入。

​	堆插入同时也是第一种建堆方式，也是直观上比较容易理解的建堆方式，但是在堆排序中，我们一般不用。

​	上面的图片中，想要插入一个新元素8，那么在数组中应该放在下标为9的位置，然后整个堆的大小加1。随后，为了维护堆的性质，9需要不断地向上看自己的父结点，如果父结点比自己小，那么应该交换二者。直到父结点的值不小于自己为止，或者已经到了树根，也就是下标为0的位置，不能继续向上找了。

​	code也很简单，函数需要一个插入的值，插入的下标从最后一个位置沿着树向上找。

## 堆插入code

```cpp
void heapinsert(int val)
{
	a[len++] = val;
	int ind = len - 1;
	int p = (len - 2) / 2;
	while (p >= 0)
	{
		if (val > a[p])
		{
			swap(a[ind], a[p]);
			ind = p;
		}
		if (p == 0)
		{
			break;
		}
		p = (p - 1) / 2;
	}
}
```

​	len就是当前堆中元素的个数，当前元素ind，其父结点为p。不断地向上调整堆。

## 堆调整

​	上面已经有堆调整的过程了，在后面插入一个元素时，为了维护堆，需要沿着树向上找，直到堆顶或者满足堆的性质为止（其实到堆顶也是满足堆的性质）。

​	那么我们现在说的堆调整是一个什么过程呢？

​	再次回到最开始堆的部分，每次需要处理堆顶，也就是优先级最高的元素，大根堆中是值最大的元素。那么我们把这个值拿走之后，树根位置应该怎样办呢？其实我们不可能把下面的值依次上调，这个过程相当于重建堆了。最方便的方法就是把当前堆顶的元素与当前最后一个元素交换，然后让len--，这样最大的元素就被len限制在堆外面了。如果是从小到大排序的话，最后这个值相当于已经放好位置了。

​	然后就是目前堆顶的元素，因为是从最后面换上来的，所以大概率是会破坏堆的性质的。所以我们需要从树根开始进行堆调整。按照规则，找到左右两孩子中较大的，如果这个值比自己大，那么自己需要下沉，直到处理到最下面没有左右孩子为止。

​	code也比较容易理解。

## 堆调整code

```cpp
void heapify(int ind)
{
	int lc = 2 * ind + 1;
	// 当左孩子存在的时候
	while (lc < len)
	{
		// PK出最大下标是哪个孩子
		int best = (lc + 1 < len) && a[lc + 1] > a[lc] ? lc + 1 : lc;

		// 最大的孩子是否比当前元素要大
		best = a[best] > a[ind] ? best : ind;

		// 如果不大，什么都不做
		if (best == ind)
		{
			break;
		}

		// 如果大，交换
		swap(a[best], a[ind]);

		// 向下传递堆调整
		ind = best;
		lc = 2 * ind + 1;
	}
}
```

## 堆排序

​	有了前面堆的概念，堆排序就很容易了。

​	上面也介绍了堆调整，实际上就是每次将最大值与最后一个元素交换位置，然后让len--，这个时候最后一个元素的位置是正确的。但是我们把最后一个元素换到堆顶，大概率会破坏堆的性质，所以就要从树根开始维护堆。有了前面代码的基础，这一步很容易做到：

## 堆排序code

```cpp
void heapSort()
{
	while (len > 1)
	{
		swap(a[0], a[--len]);
		heapify(0);
	}
}
```

​	当剩余元素数量大于1个时，才做的操作，毕竟只剩一个元素的时候，已经维护好堆的性质了，所以此时最后一个元素的位置一定是对的，不必在调整了。

## 完整的堆结构和堆排序

​	这里main函数中有两种建堆方式，读者自行实验每一种。

```cpp
#include <iostream>
using namespace std;

int n;
int a[105];
int len; // 用来记录当前堆中元素的个数

// 堆插入
void heapinsert(int val)
{
	a[len++] = val;
	int ind = len - 1;
	int p = (len - 2) / 2;
	while (p >= 0)
	{
		if (val > a[p])
		{
			swap(a[ind], a[p]);
			ind = p;
		}
		if (p == 0)
		{
			break;
		}
		p = (p - 1) / 2;
	}
}

// 堆调整，从下标ind向下调整
void heapify(int ind)
{
	int lc = 2 * ind + 1;
	// 当左孩子存在的时候
	while (lc < len)
	{
		// PK出最大下标是哪个孩子
		int best = (lc + 1 < len) && a[lc + 1] > a[lc] ? lc + 1 : lc;

		// 最大的孩子是否比当前元素要大
		best = a[best] > a[ind] ? best : ind;

		// 如果不大，什么都不做
		if (best == ind)
		{
			break;
		}

		// 如果大，交换
		swap(a[best], a[ind]);

		// 向下传递堆调整
		ind = best;
		lc = 2 * ind + 1;
	}
}

void heapSort()
{
	while (len > 1)
	{
		swap(a[0], a[--len]);
		heapify(0);
	}
}

int main()
{
	cin >> n;
	/*
	* 每进来一个元素，进行一次堆调整
	* 在insert过程中，每次从0调整
	* 相当于从上到下建堆
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
		heapinsert(a[i]);
	}
	*/

	// 从最后一个元素开始，将各个子树建成堆
	// 相当于从下到上建堆
	// 这种建堆要优于上面的
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	len = n;
	for (int i = n - 1; i >= 0; i--)
	{
		heapify(i);
	}
	
	heapSort();

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	heapinsert与heapify都是O(logn)级别的，加上n个数字的排序，总体**时间复杂度为O(n*logn)**。详细证明此处略。

### 	空间复杂度

​	我们发现整个堆排序都没有额外的空间开销，时间复杂度为O(1)。

## 小结

### 	不稳定性

​	频繁地交换操作可能导致相同的两个元素相对位置发生变化。

### 	原地排序

​	没有额外空间开销。

### 	优点

​	原地排序，效率高。

### 	缺点

​	不稳定，使用了较为复杂的堆结构，小白理解较为困难。

*（**理解并能够自行实现堆结构和堆排序，是我们迈出的重要一步**。）*
