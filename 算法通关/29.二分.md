# 二分查找和二分答案

## 二分查找

​	二分查找是进行在有序数组上的一种查找方式，它可以加快查找速度。每次选定左右边界的中点，通过中点来判断答案所在区间，这样每次都可以省去一半的查找长度，效率显著提升。

### 查找值

​	给定一个有序数组：[1, 3, 4, 5, 7, 11]。想要查找5所在的下标，没查到返回-1。

​		首先选中范围是整个数组，left = 0，right = 5，计算出此时中点mid = (left + right) / 2 = 2；

​		比较mid处的值和要查找的5，发现4 < 5，那么5一定在此时mid的右边；

​		将左边界置为mid+1，在右侧二分，也就是left = 3，right = 5，此时mid = (left + right) / 2 = 4；

​		比较mid处的值和5，发现7 > 5，那么5一定在此时mid的左边；

​		将右侧边界置为mid-1，在左侧二分，也就是left = 3，right = 3，此时mid = 3；

​		这是发现mid处的值等于要查找的5，所以把该下标返回。

​		算法结束。

### 查找值code

```cpp
int BinarySearch(int val)
{
	  int ans = -1;
	  int l = 0; //左边界
	  int r = n-1; // 右边界
	  int mid = 0; // 当前区间中点
    // 只有左边界没超过右边界时才是合法，如果超出说明没找到
	  while(l <= r)
	  {
		    mid = l + ((r-l) >> 1); // 计算出中点
        // 中点值比val大，去左侧二分
		    if(a[mid] > val)
		    {
			      r = mid - 1;
		    }
        // 中点值比val小，去右侧二分
		    else if(a[mid] < val)
		    {
			      l = mid + 1;
		    }
        // 找到了就把答案记下来并跳出循环，也可以直接返回ans的值
		    else if(a[mid] == val)
		    {
			      ans = mid;
			      break;
		    }
	  }
	
	  return ans;
}
```

### 查找值的最左/右边界

​	给定一个有序数组：[1, 3, 4, 5, 7, 11]。想要查找大于等于6的最左边界，没找到则返回-1。

​		此处可以观察到，需要返回的下标为4。

​		首选仍然是整个数组，left = 0，right = 5，此时的中点mid = (left + right) / 2 = 2；

​		此时mid处的值为4，是小于6的，说明要找的边界就在4的右边，这样就可以把左半部分丢弃了，左边界来到mid+1=3位置。

​		left = 3，right = 5，计算mid = (left + right) / 2 = 4；

​		此时mid处的值为7，说明要找的边界在该位置左边，记录答案并且右边界来到mid-1=3位置；

​		left = 3，right = 3，计算mid = (left + rigth) / 2 = 3；

​		此时mid处的值为5，说明答案在右边，但是右边没有元素了；

​		算法结束。

​	最右边界同理，对应处理一下即可。

### code

```cpp
// 找到大于等于val的最左位置
int LeftIndex(int val)
{
	  int ans = -1;
	  int l = 0;
	  int r = n-1;
	  int mid = 0;
	  while(l <= r)
	  {
		    mid = l + ((r-l) >> 1);
        // 如果中点值大于等于要找的值，那么边界一定在中点左侧
		    if(a[mid] >= val)
		    {
            ans = mid;
			      r = mid - 1;
		    }
		    else if(a[mid] < val)
		    {
			      l = mid + 1;
		    }
	  }
	
	  return ans;
}

// 找到小于等于val的最右位置
int RightIndex(int val)
{
	  int ans = -1;
	  int l = 0;
	  int r = n-1;
	  int mid = 0;
	  while(l <= r)
	  {
		    mid = l + ((r-l) >> 1);
        // 如果中点值大于要找的值，那么边界一定在中点左侧
		    if(a[mid] > val)
		    {
			      r = mid - 1;
		    }
		    else if(a[mid] <= val)
		    {
            ans = mid;
			      l = mid + 1;
		    }
	  }
	
	  return ans;
}
```

### 二分处理数组无序的情况

​	在一个数组中，返回任意一个峰值的下标，保证数组中无相等元素。

​	**峰值**：左边的元素和右边的元素都比自己小，特殊地，边界元素只要相邻的元素比自己小，也认为是峰值，可以看作数组外面是无穷小的。

​		我们先去判断边界情况：如果0位置元素大于1位置元素，直接返回0下标；如果n-1位置元素大于n-2位置元素，直接返回n-1下标；

​		去掉边界情况，那么从1到n-2范围上找峰值可以利用二分，原理如下：

​			0位置元素小于1位置元素，是一个上升的状态，而n-1位置元素小于n-2位置，是一个下降状态，所以中间必定会至少经历一个峰值。

​		我们只需要取到中点，判断中点是否为峰值，是则返回此时中点的下标；如果不是，分两种情况：

​			1.中点左边的值大于中点的值，那么到中点减一和中点的位置是一个下降状态，从左边界到中点之间必定至少存在一个峰值，那么我们去左侧区域继续二分；

​			2.中点右边的值大于中点的值，那么从中点和中点加一的位置是一个上升状态，从中点到右边界之间必定至少存在一个峰值，那么我们去右侧区域继续二分。

​		*（注意的一点：上述两种情况可以同时存在，只需要取其中一侧即可。）*

​		一直重复这个过程直到无左右边界为止。

​		算法结束。

### code

```cpp
int findPeak()
{
	int ans = -1;
    // 只有一个元素，直接返回
	if(n == 1)
	{
		return 0;
	}
    // 只有两个元素，返回较大值的下标
	if(n == 2)
	{
		return a[0] > a[1] ? 0 : 1;
	}
    
    // 判断边界情况
	if(a[0] > a[1])
	{
		return 0;
	}
	if(a[n-1] > a[n-2])
	{
		return n-1;
	}
	
    // 进行二分查找
	int l = 1;
	int r = n-2;
	int mid;
	while(l <= r)
	{
		mid = l + ((r-l) >> 1);
        // 左边界到中点有答案
		if(a[mid-1] > a[mid])
		{
			r = mid - 1;
		}
        // 中点到右边界有答案
		else if(a[mid+1] > a[mid])
		{
			l = mid + 1;
		}
        // 找到了峰值
		else if((a[mid] > a[mid-1]) && (a[mid] > a[mid+1]))
		{
			ans = mid;
			break;
		}
	}
	
	return ans;
}
```

### 练习题目

​	https://leetcode.cn/problems/binary-search （容易，模版题）

​	https://leetcode.cn/problems/search-insert-position （容易）

​	https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array （容易+）

​	https://leetcode.cn/problems/find-smallest-letter-greater-than-target （容易+）

​	https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer （容易++）

​	https://leetcode.cn/problems/successful-pairs-of-spells-and-potions （容易++，二分+排序）

​	https://leetcode.cn/problems/find-the-distance-value-between-two-arrays （容易++，二分+排序）

​	https://leetcode.cn/problems/longest-subsequence-with-limited-sum （容易++，二分+排序+前缀和）

​	https://leetcode.cn/problems/2vYnGI

​	https://leetcode.cn/problems/h-index-ii

​	https://leetcode.cn/problems/sum-swap-lcci

​	https://leetcode.cn/problems/range-frequency-queries （容易++，二分+哈希，这题需要注意避免数组的整体拷贝）

​	https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character（容易++，二分+哈希）

​	https://leetcode.cn/problems/closest-equal-element-queries （一般，二分+哈希）

​	https://leetcode.cn/problems/count-the-number-of-fair-pairs （容易++，二分+排序）

​	https://leetcode.cn/problems/most-beautiful-item-for-each-query （一般，二分+排序）

​	https://leetcode.cn/problems/snapshot-array （一般+，二分+哈希，快照）

​	https://leetcode.cn/problems/time-based-key-value-store （同上题）

​	https://leetcode.cn/problems/implement-router （设计题，未完成）

​	https://leetcode.cn/problems/find-k-closest-elements （一般++，二分+相向双指针）

​	https://leetcode.cn/problems/minimum-absolute-sum-difference （一般++，二分+排序）

​	https://leetcode.cn/problems/online-election （一般+，二分+哈希）

​	https://leetcode.cn/problems/ju-qing-hong-fa-shi-jian （一般，二分+前缀和）

​	https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array （一般，二分）

​	https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree （一般，二分+中序遍历）

​	https://atcoder.jp/contests/abc439/tasks/abc439_d （一般++，二分+哈希表）

​	

## 二分答案

​	二分答案，看名字也很容易理解，是在答案区间上二分。所以说这类问题的答案是一个固定的范围，并且一定在某种程度上满足单调性。这样子我们只需要一个函数去判断中点处的答案是否正确，然后根据题目条件和单调性继续判断去左边找答案还是右边找答案即可。

​	这部分题目有一些难度了，会有些思维的跨越，但是别着急，慢慢理解和总结，还是比较容易的。

### 例题

​	https://leetcode.cn/problems/koko-eating-bananas/

​	此题答案范围应该在[1, max]，其中max是整个数组的最大值。

​	那么在这个范围二分，每次找到的中点即为一种答案，假设此时找到的中点值为5，那么我们就假设速度是5，去计算一共所需的时间，如果这个时间比h要大，说明珂珂吃香蕉的速度慢了，我们就需要去[5, max]上找答案，也就是右侧；如果得出的时间小于等于h，那么说明速度是够用的，如果想得到更小的速度，那就去左侧二分，直到得出结果。

### code

```cpp
// 该函数用于计算当速度固定时，所需的小时数
long f(vector<int> piles, int speed)
{
    long ret = 0;
    for(int pile : piles)
    {
        ret += (pile + speed - 1) / speed;
    }
    return ret;
}

// 在可能的答案上不断二分找最终答案
int minEatingSpeed(vector<int>& piles, int h)
    {
        int maxv = 0;
        for(int pile : piles)
        {
            maxv = max(maxv, pile);
        }
        int l = 1;
        int r = maxv;
        int mid = 1;
        int ans = -1;
        while(l <= r)
        {
            mid = l + ((r-l) >> 1);
            if(f(piles, mid) <= h)
            {
                ans = mid;
                r = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }

        return ans;
    }
```

### 练习题目

​	https://leetcode.cn/problems/sqrtx

​	https://leetcode.cn/problems/first-bad-version

​	https://leetcode.cn/problems/split-array-largest-sum/

​	https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71

​	https://leetcode.cn/problems/find-k-th-smallest-pair-distance/description/

​	https://leetcode.cn/problems/maximum-running-time-of-n-computers/

**求最小**

​	https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold （容易+）

​	https://leetcode.cn/problems/minimum-time-to-complete-trips （容易++）

​	https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days （容易++）

​	https://leetcode.cn/problems/koko-eating-bananas （容易+）

​	https://leetcode.cn/problems/minimum-number-of-seconds-to-make-mountain-height-zero （容易++）

​	https://leetcode.cn/problems/minimum-time-to-activate-string （一般）

​	https://leetcode.cn/problems/heaters （一般）

​	https://leetcode.cn/problems/minimum-time-to-repair-cars （一般）

​	https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets （一般+）

​	https://leetcode.cn/problems/earliest-second-to-mark-indices-i （一般+，题意不明确？）

​	https://leetcode.cn/problems/minimum-speed-to-arrive-on-time （一般，注意边界与浮点处理）

​	https://leetcode.cn/problems/separate-squares-i （一般，浮点数二分）

​	

**求最大**

​	https://leetcode.cn/problems/h-index-ii （容易+）

​	



矩阵上二分答案：

​	https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table