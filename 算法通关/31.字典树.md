# 字典树

​	字典树是一种数据结构，它是一种字符串前缀匹配算法，相比于KMP等算法，字典树较为简单、易于理解，并且也是AC自动机的前置技能，在工程和比赛上也很常用。

## 什么是字典树？

​	给出一系列字符串：abc、abc、ab、abdef、ac。

​	从根结点开始，如果没查到字符就创建，如果查到了就顺着向下走。如图：

<img src="C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241105223018772.png" alt="image-20241105223018772" style="zoom:33%;" />

​	其中，每个圆圈代表一个结点，橙色的结点代表有单词的结尾位于此处。

​	我们需要记录每个节点经过的次数pass和以当前节点做结尾的次数end，这两个数值自有妙用。

​	这就是一颗字典树。我们发现我们可以很方便地查找每个单词，这个哈希表也能做到。那么哈希表做不到的是什么呢？前缀数量查询，比如以"ab"为前缀的字符串有几个，上述内容很明显是4个，其实就是我们记录的b节点处的pass值。那么字符串"ab"呢？不就是b节点处的end值么？所以字典树也叫前缀树。

​	这里有一个需要注意的点，就是字符被我们存放到树边上了，并不在节点中。我们可以通过字符映射索引来找到下一个节点，所以节点上并没有字符的信息。下面介绍如何实现。

## 字典树类的声明

​	上面介绍了每个树节点应该有一个pass，记录有几个字符串经过该节点了；还应该有一个end，记录有几个字符串是以该节点结尾的。

​	除此之外呢？我们应该如何索引下一个节点呢？很明显需要一个数组，当前字符如果为b，那就通过映射到下标为1的位置去寻找b节点。这样每个树节点就清晰了，pass、end、一个向下索引的next数组。

### 字典树节点类

​	根据上面的描述，很容易知道树节点都包括哪些元素，图示为插入第一个字符串时各个树节点的状态，紫色代表指向下一个节点：

<img src="C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241106113815432.png" alt="image-20241106113815432" style="zoom:33%;" />

```cpp
struct TreeNode
{
    int pass; // 用于记录当前节点被经过几次
    int end; // 用于记录当前节点被当过几次结尾
    TreeNode** next; // 存放的内容是下一个节点的地址，其本身也是一个数组

    TreeNode()
    {
        pass = 0;
        end = 0;
        next = new TreeNode*[26];
        for (int i = 0; i < 26; i++)
        {
            next[i] = nullptr;
        }
    }
};
```

### 字典树的成员

​	在一颗字典树中，所有字符串共用一个树根root，并没有其他的信息了（当然想加也可以，比如当前字典树中保存的字符串的个数等等）。

​	所以我们在字典树中只需要一个属性：root。

​	我们还应该支持字典树的插入、查询字符串的数量以及前缀字符串数量、和删除字符串。

​	故设计字典树类如下：

```cpp
class Trie
{
private:
    TreeNode* root;

public:
    Trie();
    void insert(string s);
    int count(string s);
    int precount(string s);
    void erase(string s);
    ~Trie();
};
```

## 字典树类的实现

​	接下来实现这些方法。

### 初始化

​	初始化仅仅需要树根地址即可。

```cpp
Trie::Trie()
{
    root = new TreeNode;
}
```

### 销毁

​	将根结点释放掉。

```cpp
Trie::~Trie()
{
    delete root;
}
```

### 字典树字符串的插入

​	插入还是比较简单的，只需要从树根开始走，一旦某个字符为空，就代表没走过这条路，创建加入即可。不要忘记沿途更新pass信息和结尾的end信息。

```cpp
void Trie::insert(string s)
{
    TreeNode* node = root; // 从树根开始向下插入
    node->pass++; // 树根也被经历一次
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a'; // 计算下标映射
        if (node->next[curr] == nullptr)
        {
            // 如果为空说明没走过，需创建树节点
            node->next[curr] = new TreeNode;
        }
        node = node->next[curr]; // node沿着路径向下走
        node->pass++; // 对于经过的每个点，pass++
    }
    node->end++; // 结尾标志
}
```

### 字典树的字符串数量查询

​	在字典树中查询字符串的数量，就看该字符串最后一个字符在树中的end值，如果找不到最后一个字符，说明没有该字符串，返回0即可。

```cpp
int Trie::count(string s)
{
    TreeNode* node = root; // 从树根开始向下查找
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a'; // 计算下标映射
        if (node->next[curr] == nullptr)
        {
            // 如果为空说明没有该字符串，直接返回0
            return 0;
        }
        node = node->next[curr]; // node沿着路径向下走
    }
    return node->end; // 返回数量
}
```

### 字典树的前缀字符串数量查询

​	对于前缀，相比于上面的代码，这里返回的是结尾字符的pass值，有几个字符串经过该节点，说明有几个字符串前缀是要查找的字符串。

```cpp
int Trie::precount(string s)
{
    TreeNode* node = root; // 从树根开始向下查找
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a'; // 计算下标映射
        if (node->next[curr] == nullptr)
        {
            // 如果为空说明没有以该字符串为前缀的字符串，直接返回0
            return 0;
        }
        node = node->next[curr]; // node沿着路径向下走
    }
    return node->pass; // 返回数量
} 
```

### 字典树字符串的删除

​	删除就是把沿途节点的pass值减去，再把结尾的end值减去即可。对于只出现一次的字符串，如果要删掉，查找到pass值为1的节点就可以了，后面直接释放掉。

```cpp
void Trie::erase(string s)
{
    if (count(s) > 0)
    {
        TreeNode* node = root; // 从树根开始向下查找
        node->pass--; // 根结点的少经历一次
        for (int i = 0; i < s.size(); i++)
        {
            int curr = s[i] - 'a'; // 计算下标映射
            if (--node->next[curr]->pass == 0)
            {
                // 如果下一个节点只被经过一次，后面不用看，直接释放掉空间即可
                TreeNode* temp = node->next[curr];
                delete temp;
                // 别忘了当前节点的该字符的next域置空，不然是随机数，会出错
                node->next[curr] = nullptr;
                return;
            }
            node = node->next[curr]; // node沿着路径向下走
        }
        node->end--; // 结尾数量减去
    }
}
```

## 字典树类实现版整体code

​	附主函数测试，无注释：

```cpp
#include <iostream>
#include <string>
using namespace std;

struct TreeNode
{
    int pass;
    int end;
    TreeNode** next;

    TreeNode()
    {
        pass = 0;
        end = 0;
        next = new TreeNode*[26];
        for (int i = 0; i < 26; i++)
        {
            next[i] = nullptr;
        }
    }
};

class Trie
{
private:
    TreeNode* root;

public:
    Trie();
    void insert(string s);
    int count(string s);
    int precount(string s);
    void erase(string s);
    ~Trie();
};

Trie::Trie()
{
    root = new TreeNode;
}

void Trie::insert(string s)
{
    TreeNode* node = root;
    node->pass++;
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a';
        if (node->next[curr] == nullptr)
        {
            node->next[curr] = new TreeNode;
        }
        node = node->next[curr];
        node->pass++;
    }
    node->end++;
}

int Trie::count(string s)
{
    TreeNode* node = root;
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a';
        if (node->next[curr] == nullptr)
        {
            return 0;
        }
        node = node->next[curr];
    }
    return node->end;
}

int Trie::precount(string s)
{
    TreeNode* node = root;
    for (int i = 0; i < s.size(); i++)
    {
        int curr = s[i] - 'a';
        if (node->next[curr] == nullptr)
        {
            return 0;
        }
        node = node->next[curr];
    }
    return node->pass;
} 

void Trie::erase(string s)
{
    if (count(s) > 0)
    {
        TreeNode* node = root;
        node->pass--;
        for (int i = 0; i < s.size(); i++)
        {
            int curr = s[i] - 'a';
            if (--node->next[curr]->pass == 0)
            {
                TreeNode* temp = node->next[curr];
                delete temp;
                node->next[curr] = nullptr;
                return;
            }
            node = node->next[curr];
        }
        node->end--;
    }
}

Trie::~Trie()
{
    delete root;
}

int main()
{
    Trie tr;
    tr.insert("abc");
    tr.insert("abc");
    tr.insert("ab");
    tr.insert("abdef");

    cout << tr.count("abdef") << endl;
    cout << tr.precount("ab") << endl;

    tr.erase("abdef");

    cout << tr.count("abdef") << endl;
    cout << tr.precount("ab") << endl;

    return 0;
}
```

## 静态数组实现字典树

​	上面的类在工程上合适用，但是比赛手搓一个还是很慢的。

​	所以我们采用一个二维数组实现建树。

​	一个变量cnt记录从1号开始的节点（节点的编号，零号位置弃而不用），每次加入节点++cnt。

​	这时，pass[t]保存的是t号节点被经过几次，e[t]保存的是t号节点做了几次结尾。

​	其余与上述一致，这里仅需要考虑清楚如何寻找下一个节点即可。

## 字典树静态数组实现版code

```cpp
#include <iostream>
#include <string>
using namespace std;

#define N 10005

int tree[N][26];
int pass[N];
int e[N];
int cnt = 1;

void clear()
{
	for (int i = 1; i <= cnt; i++)
	{
		for (int j = 0; j < 26; j++)
		{
			tree[i][j] = 0;
		}
	}
}

void insert(string s)
{
	int t = 1;
	pass[t]++;
	for (int i = 0; i < s.size(); i++)
	{
		int curr = s[i] - 'a';
		if (tree[t][curr] == 0)
		{
			tree[t][curr] = ++cnt;
		}
		t = tree[t][curr];
		pass[t]++;
	}
	e[t]++;
}

int count(string s)
{
	int t = 1;
	for (int i = 0; i < s.size(); i++)
	{
		int curr = s[i] - 'a';
		if (tree[t][curr] == 0)
		{
			return 0;
		}
		t = tree[t][curr];
	}
	return e[t];
}

int precount(string s)
{
	int t = 1;
	for (int i = 0; i < s.size(); i++)
	{
		int curr = s[i] - 'a';
		if (tree[t][curr] == 0)
		{
			return 0;
		}
		t = tree[t][curr];
	}
	return pass[t];
}

void erase(string s)
{
	int t = 1;
	pass[t]--;
	for (int i = 0; i < s.size(); i++)
	{
		int curr = s[i] - 'a';
		if (--pass[t] == 0)
		{
			tree[t][curr] = ++cnt;
		}
		t = tree[t][curr];
	}
	e[t]--;
}

int main()
{
	insert("abc");
	insert("abc");
	insert("ab");
	insert("abdef");

	cout << count("abdef") << endl;
	cout << precount("ab") << endl;

	erase("abdef");

	cout << count("abdef") << endl;
	cout << precount("ab") << endl;

	return 0;
}
```

## 课后练习

​	https://www.nowcoder.com/practice/c552d3b4dfda49ccb883a6371d9a6932

​	https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/

​	https://leetcode.cn/problems/word-search-ii/
