# 差分与离散化

*前置知识：一维前缀和、二维前缀和*

​	差分就是预先处理一段区间，然后通过前缀和的加工方式使之变成想要的结果。

​	离散化是把数据加工为数轴上的整数，并且不关心数据的值，只关心数据的次序。

## 一维差分

​	给定一段区间，区间内的每个值+v，操作k次，那么时间复杂度为O(nk)，当区间长度接近n，且操作次数接近n时，整个过程的时间消耗是n^2级别的，这显然不能接受。

​	我们可以预处理差分数组，让差分数组下标为l的元素+v，并且让下标为r+1的元素-v，这样只需要加工一次前缀和就能得到想要的结果了。

​	如图所示：

![image-20241101232013966](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241101232013966.png)

​	一开始数组全为0，我们让其在[1，6]范围上都+3。那么差分之后：

![image-20241101232142853](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241101232142853.png)

​	然后我们加工一次前缀和：

![image-20241101232220933](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241101232220933.png)

​	就得到目的操作了。

​	那么如何理解这个做法呢？我们让第一个数字，也就是l下标的位置+3，标记为后续数字都需要+3，但是我们只需填l这一个位置，一直到哪里呢？到最后一个位置的下一个位置，把+3这个效果消除掉，也就是在r+1的位置-3。这样，就做到了O(1)的时间去处理区间加的操作了。

​	我们只需最后遍历一遍数组，加工出前缀和即为我们所求，时间复杂度为O(n)。

​	很显然，我们先要把所有操作标记做完，最后加工前缀和，也就是区间加过程中，我们没办法知道某个位置的答案。

​	上述内容为树状数组或线段树可以解决的范畴，差分只能先操作，最后加工求答案。

### 例题

​	https://leetcode.cn/problems/corporate-flight-bookings

## 等差数列差分

​	这个是一维差分的变形，这里在区间[l，r]上加的是一段等差数列。

​	还是准备出一段数组，我们让其在[2，6]上加一段等差数列，首项为2，公差为2，效果如下：

![image-20241102213855002](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241102213855002.png)

​	那么如何利用差分做到这一点呢？

​	我们知道，虽然等差数列不是定值，但是其差值是定值，也就是在每一个数还未加公差的时候，值是一样的，故我们在原数组上这样加工：

​	![image-20241102214441588](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241102214441588.png)

​	设s为起始位置的值，s = 2，e为结束位置的值，e = 10。设公差为d，此处d = 2。

​	这样设置差分数组：l位置加s，l+1位置加d-s，r+1位置减d+e，r+2位置加e。于是得到了上面的数组。我们加工只需要加工两次前缀和即可：

![image-20241102214824319](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241102214824319.png)

### 例题

​	https://www.luogu.com.cn/problem/P4231

## 二维差分

​	二维差分与一维差分类似，也是预先处理，然后统一加工，那么二维差分如何预先处理呢？

​	在二维差分中，应该是一个矩形区域+v，根据二维前缀和，我们假设左上角为(a,b)，右下角为(c,d)。那么把a,b位置+v，c+1,b位置-v，a,d+1位置-v，c+1，,d+1位置+v。这样处理四个点就好了。我们处理(1,3)到(4,5)，如下：

![image-20241102223949051](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241102223949051.png)

​	再加工一次二维前缀和：

![image-20241102224102372](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20241102224102372.png)

​	得到我们想要的结果。

​	那么如何理解呢？

​	在左上角+v，对于其下方和右方，都有+v的影响，那么就在下方和右方减去这个影响，右下角被有了-2*v的影响，就在右下角+v减去多余的影响。

### 例题

​	https://leetcode.cn/problems/stamping-the-grid

## 离散化

​	离散化就是把非整数、不连续的点变成连续的整数的点。因为这个特性，我们只有在不关心数值，只关心次序的时候进行离散化。

​	这里通过例子说明：

​		给出一些线段，给出覆盖层数最高是几：[1,3]，[2,5]，[1328447642,2043534257]。

​		此题输出2，是[2,3]这段。

​		观察到后面区间很大，不可能开这么大的数组存信息，故我们离散化，把边界排好序：[1,2,3,5,1328447642,2043534257]。每个位置换成该位置下标，从1开始，则：[1,2,3,4,5,6]。此时便是[1,3]，[2,4]，[5,6]这三段区间上有覆盖。这时空间利用就很小了。我们只关心他们的相对位置，而不关心具体数值。所以我们可以这样做。

​	实际运用相当灵活，具体内容需做题体会。
