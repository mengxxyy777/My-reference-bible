# 单调栈

​	单调栈是一种栈的高级应用技巧，对于接触编程不久的朋友来说，理解题目有些许困难。其实在学习数据结构的时候，已经接触过单调栈了，在栈的应用中，有一个逆波兰表达式，给各个字符设定优先级，在栈中的字符遵循一定的单调性，就能完成任务。

​	我们由简单到复杂，慢慢来理解单调栈。

## 单调栈的典型应用

​	题目链接：https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb

​	朴素做法：对于每个位置，向左向右遍历，找到这个最近且小于自己的下标即可。时间复杂度为O(n^2)。

​	单调栈可以把这个时间复杂度降到O(n)。那么看看单调栈是怎么做的。

​	既然叫单调栈，我们需要维护栈的单调性，怎么维护呢？我们让栈内元素从栈底到栈顶单调递增，且栈内存的是下标（并不都是这样，根据具体的题目决定）。

​	我们逐个遍历数组中的元素，如果发现当前值小于栈顶下标对应的值，那么元素入栈会破坏单调性，所以这个时候要先出栈，直到栈顶元素对应值小于当前元素，才可入栈。我们遍历的时候发现，每次只要有元素出栈，该元素下面的元素对应的值一定小于自己且离自己最近，同样的，当前遍历到的元素也一定是这样的。同时由于遍历的顺序是从左到右，故出栈元素下面的元素对应的是左边的答案，当前遍历到的元素是右边的答案。我们先忽略有重复元素的情况。

​	这样从头到尾遍历之后，来到清算阶段，栈内剩余的元素一定是找不到右边比自己小且离自己最近的元素了，标为-1。对于栈内剩余的最后一个元素，它不仅右边是-1，左边也找不到答案，所以也标为-1。最后剩下的元素实际上是整个数组的最小值。

​	对于有重复值的元素，我们遵循一个原则，那就是严格大压小。在遇到栈顶元素和当前元素相同时，也要出栈，但是这个时候记录的右答案与自己相同，是错误答案，这个时候就需要从后向前修正。如果发现错误答案，则将右侧答案给到当前元素的右答案。

​	其实有些题目中甚至不需要修正重复值带来的错误答案，也可以求出正确的解，例如练习题目中的第三题，甚至不需要严格单调，也可以求出正确的解，例如练习题目中的第一题。

​	还有要注意的是本题对时间要求较为严格，C++的小伙伴需要快读快写，或进行一些其他优化输入输出的操作才可通过。本人代码采用了快读。

​	整体代码如下：

```cpp
#include <iostream>
using namespace std;

int arr[1000005];
int st[1000005];
int r;
int ans[1000005][2];

// 快读
int read()
{
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            w = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar(); 
    }
    return x * w;
}

int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        arr[i] = read();
    }

    for(int i = 0; i < n; i++)
    {
        // 维护栈的单调性
        // 元素出栈时，可以记录其左右答案
        while(r > 0 && arr[i] <= arr[st[r-1]])
        {
            r--;
            ans[st[r]][0] = r == 0 ? -1 : st[r-1];
            ans[st[r]][1] = i;
        }
        // 符合条件后入栈
        st[r++] = i;
    }
    
    // 清算阶段，处理栈内剩余元素
    while(r > 0)
    {
        r--;
        ans[st[r]][0] = r == 0 ? -1 : st[r-1];
        ans[st[r]][1] = -1;
    }
    
    // 修正值阶段
    for(int i = n-2; i >= 0; i--)
    {
        if(ans[i][1] != -1 && arr[ans[i][1]] == arr[i])
        {
            ans[i][1] = ans[ans[i][1]][1];
        }
    }

    for(int i = 0; i < n; i++)
    {
        cout << ans[i][0] << " " << ans[i][1] << endl;
    }
}

```

## 逆波兰表达式

​	这个可以说非常经典，也是你接触过，但是不知道原理的单调栈应用。

​	由于发布过该问题，详细阅读直接链接过去：

​	https://blog.csdn.net/m0_74056693/article/details/140895887?spm=1001.2014.3001.5502

## 练习题目

​	练手：https://leetcode.cn/problems/daily-temperatures/

​	较难：https://leetcode.cn/problems/sum-of-subarray-minimums

​	较难：https://leetcode.cn/problems/largest-rectangle-in-histogram/

​	懂了上一个题，这题就比较容易了，需要矩阵压缩逐行计算：https://leetcode.cn/problems/maximal-rectangle/

## 单调栈的进阶用法

​	注意此处只是单纯的使用单调栈，并不涉及与其他更复杂的算法如动态规划结合使用。

​	我们单调栈通过对题目分析，先利用单调性维持一个单调栈，随后在搜集答案的时候，如果栈顶元素对答案没有贡献，就出栈。相当于单调栈利用单调性维护了答案的可能性。

## 进阶练习题目

​	https://leetcode.cn/problems/maximum-width-ramp/

​	https://leetcode.cn/problems/remove-duplicate-letters/

​	https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de

​	https://leetcode.cn/problems/count-submatrices-with-all-ones/

