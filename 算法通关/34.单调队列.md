# 单调队列

​	单调队列同单调栈一样，可以优化动态规划等。这里的理解有了单调栈的基础其实还是比较容易的，复杂的是处理过程，因为我们此处的队列指的是双端队列。还需要有滑动窗口的基础，单调队列学起来会更容易一些。

​	还是由简入繁吧！

## 单调队列的典型应用

​	求滑动窗口的最大值。

​	原题链接：https://leetcode.cn/problems/sliding-window-maximum/

​	朴素做法就是逐个窗口去扫，记录最大值，但是我们知道这种做法的时间复杂度为O(n^2)，面对大数据量肯定跑不完的。那么怎么做呢？

​	此题应用单调队列可以将时间复杂度降为O(n)。

​	首先准备一个双端队列，可以用语言提供的，也可以自己用数组模拟。常数时间上肯定是自己模拟的快一些。队列维持一个大到小的单调性，这样每次取最大值只需去头位置取即可。当有新元素进入时，需要判断两个问题：1、是否会破坏单调性；2、是否超出窗口限制。

​	第一个问题：当前元素进入队列时，如果大于等于队尾元素对应的值，那么就破坏了单调性。此时依次判断队尾元素，对应值小于等于当前元素都是不行的，需要把队尾元素从尾巴弹出，直至满足单调性为止。

​	第二个问题：由于新进入的元素，那么有可能导致当前队列维护的最大值元素下标位置被窗口抛弃掉，此时再用该信息就出错了。所以我们需要比较队列头下标和最大值下标，看看是否过期，如果过期，则把头位置的元素从头部弹出。

​	这样一直做完，也就收集了所有答案。

## 参考代码如下：

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k)
    {
        int dq[100005] = {0};
        int h = 0;
        int t = 0;
        int n = nums.size();
        vector<int> ans;
        for(int i = 0; i < k; i++)
        {
            while(h < t && nums[dq[t-1]] <= nums[i])
            {
                t--;
            }
            dq[t++] = i;
        }
        ans.push_back(nums[dq[h]]);
        for(int i = k; i < n; i++)
        {
            if(i-dq[h] >= k)
            {
                h++;
            }
            while(h < t && nums[dq[t-1]] <= nums[i])
            {
                t--;
            }
            dq[t++] = i;
            ans.push_back(nums[dq[h]]);
        }

        return ans;
    }
```

## 练习题目

​	维护两个单调队列：https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

​	跟例题一样：https://www.luogu.com.cn/problem/P2698

​	对前缀和信息采取单调队列的处理：https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/

​	https://leetcode.cn/problems/max-value-of-equation/

​	好题，结合二分答案+贪心+单调队列（单调性被贪心处理掉了）：https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/