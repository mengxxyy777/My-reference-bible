# 最小生成树

​	经典的最小生成树有两种方式，常用的是“K”算法，操作边；还有一个“P”算法是操作点。

## Kruskal

*前置：并查集*

​	模板题：https://www.luogu.com.cn/problem/P3366

​	对于所有边的信息，可以先存储，这样相当于建图：

```cpp
struct Edge
{
	int u, v, w;
};

Edge edge[MAXM]; // 边集
```

​	随后按照边权进行排序，从小到大，基于贪心策略。

​	依次对所有边进行遍历，相当于边的是否选择。并查集的作用就是排除掉环的存在。

​	假设有n个点，最小生成树中一定有n-1调边。用一个变量记录下来就可以了。

## code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define MAXN 50005
#define MAXM 500005

struct Edge
{
	int u, v, w;
};

Edge edge[MAXM]; // 边集
int n, m; // 点数，边数，手动输入
int father[MAXN];
int edgesnums;
int ans;

// 比较器，按照边权由小到大排序
bool cmp(Edge a, Edge b)
{
	return a.w < b.w;
}

int find(int x)
{
	if (x != father[x])
	{
		father[x] = find(father[x]);
	}
	return father[x];
}

void merge(int x, int y, int w)
{
	int fx = find(x);
	int fy = find(y);
	// 只有不在一个集合中，也就是加了这条边不会出现环的情况下，才统计答案
	if (fx != fy)
	{
		father[fx] = fy;
		edgesnums++;
		ans += w;
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		cin >> edge[i].u >> edge[i].v >> edge[i].w;
	}
	sort(edge, edge + m, cmp);

	for (int i = 0; i <= n; i++)
	{
		father[i] = i;
	}

	for (int i = 0; i < m; i++)
	{
		int tu = edge[i].u;
		int tv = edge[i].v;
		int tw = edge[i].w;
		merge(tu, tv, tw);
	}

	if (edgesnums == n - 1)
	{
		cout << ans;
	}
	else
	{
		cout << "orz";
	}

	return 0;
}
```

## Prim

*前置：堆， STL中的堆*

​	Prim算法与Kruscal算法的不同点就是：Prim算法是操作点集。答案集一开始为空，我们需要选一个点作为起点，加入到答案集中。每次通过走权值较小的边，同样是贪心策略，一直到所有点都加入到答案集为止。

​	选好起点后，将所有以该点为起点的边加入到堆里（用到的一定是小根堆），然后，只要堆不空，就进行操作：把当前堆顶的边弹出，如果该边去往的点已经在答案集中，就什么也不做；如果不在答案集，说明该点需要加入答案集，最小生成树也就解锁新的点，解锁新的点同时也就解锁以该点为起点的所有边。这个时候把这些边继续加入到堆中，等待操作就好了。

​	我们可以等堆跑完，没有元素为止，也可以判断答案集中点的个数来提前终止操作。二者不仅时间复杂度相同，细微时间差别也不大，且后者实现需要多写两行代码。故一般让堆中元素弹完自行结束即可。

## code

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

#define MAXN 100005 // 最大点数
#define MAXM 300005 // 最大边数

int n, m;

// 链式前向星存图，这里注意无向图正反两个方向都需要存边
int head[MAXN];
int nex[MAXM << 1];
int to[MAXM << 1];
int wei[MAXM << 1];
int cnt = 1;

// 标记每个点是否在答案集中
bool vis[MAXN];

// 记录边的编号和对应权值，小根堆放入的边需要根据权值信息排序，同时还需要知道该边的编号
struct HeapEdge
{
	int edgeno, w;
	bool operator < (const HeapEdge& v) const
	{
		return w == v.w ? edgeno < v.edgeno : w > v.w;//小根堆 
	}
};
// 这里注意C++同学，小根堆放结构体类型需要自行定义运算符重载
priority_queue<HeapEdge> heap;

void addedge(int u, int v, int w)
{
	nex[cnt] = head[u];
	to[cnt] = v;
	wei[cnt] = w;
	head[u] = cnt++;
}

int main()
{
	cin >> n >> m;
	int u, v, w;
	for (int i = 0; i < m; i++)
	{
		cin >> u >> v >> w;
		addedge(u, v, w);
		addedge(v, u, w);
	}
	
    // 以1号点为起点，标记为在答案集，同时将所有以1为起点的边都加入到堆中
	vis[1] = true;
	for (int e = head[1]; e != 0; e = nex[e])
	{
		HeapEdge edge;
		edge.edgeno = e;
		edge.w = wei[e];
		heap.push(edge);
	}

	long long ans = 0;
	int nodecnt = 1;
    // 只要堆中还有边
	while (!heap.empty())
	{
        // 弹出堆顶的边，记录该边的终点和权值
		HeapEdge edge = heap.top();
		heap.pop();
		int tmp = to[edge.edgeno];
		int cost = wei[edge.edgeno];
        
        // 如果该终点不在答案集中，才加入到答案集，并将所有以该点为起点的边加入到堆中
		if (!vis[tmp])
		{
			nodecnt++;
			vis[tmp] = true;
			ans += cost;
			for (int e = head[tmp]; e != 0; e = nex[e])
			{
				HeapEdge edge;
				edge.edgeno = e;
				edge.w = wei[e];
				heap.push(edge);
			}
		}
	}
	
    // 结束的时候检查答案集中顶点数量是否为输入值，不是输出-1（或者题目要求的其他内容）
	if (nodecnt == n)
	{
		cout << ans;
	}
	else
	{
		cout << -1;
	}

	return 0;
}
```

## Prim算法的优化

​	Prim算法的时间复杂度与Kruscal算法相同，实现却复杂一些。实际上Prim算法可以通过反向堆索引来优化，可以降低一些时间复杂度，以前是同边数量有关，优化后就与点的数量有关。

​	感兴趣的同学自行学习。此处暂时不详细解释。

## 练习题目

​	模板题：https://www.luogu.com.cn/problem/P2330
