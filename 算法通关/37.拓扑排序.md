# 拓扑排序

​	拓扑排序是一种比较容易理解的图算法。在学习到数据结构这门课时，如果讲到拓扑排序，一定会举的例子就是大学课程的前置课程。

​	在学习一门课之前，要保证所以该课程所需的前置知识都已经学过了。体现在图中就是该节点所有指向它的节点都应放在它的前面。

## 拓扑排序详解

​	首先注意的是，拓扑序不一定是只有一种。且拓扑图一定是有向图且无环的。

​	对于一张图，我们可以选择邻接表的方式存，也可以选择链式前向星的方式存。

​	在存储图的同时，记录每个顶点的入度。

​	准备一个队列，发现某个点入度为0就加入队列即可。

​	一开始就遍历所有点，如果入度为0就加入队列。

​	只要队列不空，就一直处理。

​	每次处理队列头部元素，对于该顶点的所有邻居，入度减去1，相当于将当前点删除，或者说对邻居们的影响减去。

​	这样还可以统计入度，如果发现减完入度为0，说明该点可以处理了，就加入队列等待处理。

​	结束时需判断答案的长度是否等于顶点个数，如果等于是正常的结果。

​	如果图中有环，我们不能得到正确的答案，答案的长度自然就不为顶点个数了。

## 拓扑排序模板

### 邻接表存图

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 1005; // 顶点最大个数 

int n, m; // 顶点数和边数 
int indegree[MAXN]; // 用于记录每个顶点的入度 
int queue[MAXN]; // 用于保存可以处理的点，也就是入度为0的点 
int h, t; // 队列的头和尾巴 
vector< vector<int> > graph(MAXN); // 邻接表存图 
vector<int> ans; // 记录拓扑排序的答案 

// 邻接表加边 
void addedge(int u, int v)
{
	graph[u].push_back(v);
}

// 拓扑排序 
void topo()
{
	for (int i = 1; i <= n; i++)
	{
		if (indegree[i] == 0)
		{
			queue[t++] = i;
		}
	}

	// 当队列不空时
	while (h < t)
	{
		// 处理队首第一个元素
		int cur = queue[h];
		ans.push_back(cur);
		h++; // 记录下来就弹出
		for (int i = 0; i < graph[cur].size(); i++)
		{
			int tmp = graph[cur][i];
			// 如果发现当前点的邻居入度为0，则入队
			if (--indegree[tmp] == 0)
			{
				queue[t++] = tmp;
			}
		}
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		int u, v;
		cin >> u >> v;
		addedge(u, v);
		indegree[v]++; // 对于每个被指向的点，入度加1 
	}

	// 进行拓扑排序 
	topo();

	// 如果图中无环
	if (ans.size() == n)
	{
		for (int i = 0; i < ans.size(); i++)
		{
			cout << ans[i] << " ";
		}
	}
	else
	{
		cout << -1;
	}

	return 0;
}
```

### 链式前向星存图

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 200005; // 顶点最大个数 
const int MAXM = 200005; // 边最大条数

int n, m; // 顶点数和边数 
int indegree[MAXN]; // 用于记录每个顶点的入度 
int queue[MAXN]; // 用于保存可以处理的点，也就是入度为0的点 
int h, t; // 队列的头和尾巴 
vector<int> ans; // 记录拓扑排序的答案 

// 链式前向星存图
int head[MAXN];
int nex[MAXM];
int to[MAXM];
int cnt = 1;

void addedge(int u, int v)
{
	nex[cnt] = head[u];
	to[cnt] = v;
	head[u] = cnt++;
}

// 拓扑排序 
void topo()
{
	for (int i = 1; i <= n; i++)
	{
		if (indegree[i] == 0)
		{
			queue[t++] = i;
		}
	}

	while (h < t)
	{
		// 处理队首第一个元素
		int cur = queue[h];
		ans.push_back(cur);
		h++; // 记录下来就弹出
		for (int e = head[cur]; e != 0; e = nex[e])
		{
			int tmp = to[e];
			// 如果发现当前点的邻居入度为0，则入队
			if (--indegree[tmp] == 0)
			{
				queue[t++] = tmp;
			}
		}
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		int u, v;
		cin >> u >> v;
		addedge(u, v);
		indegree[v]++; // 对于每个被指向的点，入度加1 
	}

	// 进行拓扑排序 
	topo();

	// 如果图中无环
	if (ans.size() == n)
	{
		for (int i = 0; i < ans.size(); i++)
		{
			if(i != ans.size()-1)
			{
				cout << ans[i] << " ";
			}
			else
			{
				cout << ans[i];
			}
		}
	}
	else
	{
		cout << -1;
	}

	return 0;
}
```



## 拓扑排序练习题

​	模板题：https://leetcode.cn/problems/course-schedule-ii/

​			https://www.luogu.com.cn/problem/B3644

​	类似模板题：https://leetcode.cn/problems/Jf1JuT/

​	开动脑筋：https://leetcode.cn/problems/stamping-the-sequence/

## 拓扑排序拓展

​	利用拓扑序列将信息传递到最后的节点，有点树型dp的意思了！

​	练习题目：

​	https://www.luogu.com.cn/problem/P4017

​	https://leetcode.cn/problems/loud-and-rich/

​	https://leetcode.cn/problems/parallel-courses-iii/

​	基环树，注意分情况讨论：https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/