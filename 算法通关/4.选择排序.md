# 选择排序

​	选择排序是一种**比较排序**，是最简单的排序算法之一。

## 何为选择排序？

​	选择排序，就是划分出两个集合，一个集合已经排好序，另外一个集合待排序。每次操作需要在待排序集合中找到最小元素，并将其插入到已经排好序集合的最后。我们需要从排好序的集合为空，一直操作到待排序的集合为空，每次可以排好一个元素。

## 选择排序过程

​	我们用一个数组来模拟整个排序过程（下标从0开始），前面是已经排好序的部分，后面是待排序部分。加粗部分代表已经排好序。

​		初始数组：[1, 4, 6, 3, 5, 2]。    接下来从第一个待排序数组开始搜索所有待排序数字的最小值，并与当前位置交换。

​		我们发现最小的数字就是1：[**1**, 4, 6, 3, 5, 2]。    继续找最小值，并与1后面的数字交换。

​		第二小的数字是2：[**1, 2**, 6, 3, 5, 4]。    直接交换两个数字，省时省力。

​		第三小的数字是3：[**1, 2, 3**, 6, 5, 4]。

​		第四小的数字是4：[**1, 2, 3, 4**, 5, 6]。    这个时候我们发现数组已经有序了，但是算法并不知道，还不能停。

​		第五小的数字是5：[**1, 2, 3, 4, 5**, 6]。

​		最大的数字是6：[**1, 2, 3, 4, 5, 6**]。    算法结束。

## code

```c++
#include <iostream>
#include <vector>
using namespace std;

// 打印数组
void printResult(vector<int>& vec)
{
	for (int x : vec)
	{
		cout << x << " ";
	}
	cout << endl;
}

// 选择排序
void selectSort(vector<int>& vec)
{
	for (int i = 0; i < vec.size()-1; i++)
	{
		int min = vec[i];
		int ind = i;
		for (int j = i + 1; j < vec.size(); j++)
		{
			if (vec[j] < min)
			{
				min = vec[j];
				ind = j;
			}
		}

		swap(vec[i], vec[ind]);
	}
}

int main()
{
	vector<int> vec;
	vec.push_back(1);
	vec.push_back(4);
	vec.push_back(6);
	vec.push_back(3);
	vec.push_back(5);
	vec.push_back(2);

	// 先看看排序前的数组
	cout << "排序前：" << endl;
	printResult(vec);

	// 进行选择排序
	selectSort(vec);

	// 再看看排序后的数组
	cout << "排序后：" << endl;
	printResult(vec);

	return 0;
}
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	我们需要对每个位置都找到一个答案，并与之交换。对于每个位置，需要遍历后面的所有待排序元素来找到答案，最长需要遍历整个数组，最短只需要向后遍历一个元素即可，是一个O(n)的操作。整体上n个位置，每个位置是O(n)的时间复杂度，整体**时间复杂度为O(n^2)**。

### 	空间复杂度

​	由于没有额外的数组，并且交换两个数的操作也只用了一个临时变量（其实也可以不用，具体见星球专栏 “一些小技巧” ）。故整体**空间复杂度为O(1)**。

## 小结

### 	不稳定性

​	交换两个数字的时候可能会改变两个数字的相对位置，故选择排序是一种**不稳定**的排序算法。

### 	原地排序

​	选择排序未使用额外的辅助空间，故选择排序是一种**原地排序**。

### 	优点

​	选择排序的优点就是**简单、直观**，并且在**小数据量**的情况下性能很优异。

### 	缺点

​	选择排序的缺点是在面对**大数据量**的时候跑不动，需要更改算法或者优化算法。

## 选择排序的优化

（*注：此处部分内容属于进阶内容，看不懂也没关系，后续会讲到*）

​	我们发现对于每个位置，需要从前向后遍历待排序的数组，找出最小值，时间复杂度为O(n)，这个过程是可以被优化的，每次在一个动态区间内求最小值，我们可以想到用**线段树**来减少找最小值的时间；或者前面学过了STL中的**优先队列**，我们发现这个性质刚好能满足我们的需求，每次弹出一个最小值，放到排好序数组的末尾，然后将这个数字删去。并且优先队列找最小值的时间复杂度同线段树，都可以优化到log级别。后续会讲到。

​	此处优化部分待更新……