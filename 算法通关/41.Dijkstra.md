# Dijkstra

​	Dijkstra是我接触到的第一个图中最短路算法，当然不包括一些单纯的广搜深搜求解的问题。Dijkstra实际上是动态规划+贪心的思想，或者也可以看成广搜优化。

​	Dijkstra算法是单源最短路算法，也就是从一个点出发到各个点的最小值，且边权不为负数。

​	本次课程内容是堆优化版本，基础版本时间效率比较差，基本1000个点就达到上限了，而题目不可能单纯让我们写一个dijkstra算法模板，所以基础班没什么意义。如果是初学者，可以先去学基础版，再来看堆优化版，理解会更好一点。当然可以直接看堆优化版，不影响学习。该算法对于新手朋友来讲确实需要一些时间和练习去帮助学习的，所以请多看多练。

## Dijkstra算法描述

​	对于一张图，准备一个dis数组，记录着起点到所有点的最短距离，初始化为无穷大。准备一个vis数组，记录着每个点的访问情况。准备一个小根堆，包含着起点要去往的点，以及去往该点的距离。按照距离组织该小根堆。

​	首先选定起点，将起点的dis值改为0。将起点和0加入到堆。

​	当堆不空，就弹出：

​		如果弹出的点已经弹出过了，continue掉；

​		如果还没弹出过，标记为弹出过，然后处理：

​			处理时遍历所有以该点为起点的边，如果该边的终点的dis值可以更优，就把该点和优的值加入到堆中，否则不处理。

​	直到堆为空。dis如果仍为初始值，则说明达不到。

## Dijkstra算法代码实现

​	直接来个模板题吧：https://www.lanqiao.cn/problems/1122/learning/?page=1&first_category_id=1&second_category_id=8

​	代码如下，采用链式前向星建图，堆优化的Dijkstra算法：

```cpp
#include <iostream>
#include <queue>
#include <limits.h>
using namespace std;

#define MAXN 300005
#define MAXM 1000005

int n, m;
int head[MAXN];
int nex[MAXM];
int to[MAXM];
long long wei[MAXM];
int cnt = 1;
long long dis[MAXN];
bool vis[MAXN];

struct P
{
    int p;
    long long dist;
    bool operator<(const P& t) const
    {
        return dist > t.dist;
    }
};

priority_queue<P> q;

int main()
{
    cin >> n >> m;
    int u, v;
    long long w;
    for(int i = 0; i < m; i++)
    {
        cin >> u >> v >> w;
        nex[cnt] = head[u];
        to[cnt] = v;
        wei[cnt] = w;
        head[u] = cnt++;
    }

    for(int i = 0; i <= n; i++)
    {
        dis[i] = LONG_MAX;
        vis[i] = false;
    }

    dis[1] = 0;
    q.push({1,0});
    while(!q.empty())
    {
        P tmp = q.top();
        q.pop();
        int u = tmp.p;
        if(vis[u])
        {
            continue;
        }
        vis[u] = true;
        for(int e = head[u]; e != 0; e = nex[e])
        {
            int t = to[e];
            int w = wei[e];
            if(!vis[t] && dis[u] + w < dis[t])
            {
                dis[t] = dis[u] + w;
                q.push({t, dis[u] + w});
            }
        }
    }

    for(int i = 1; i <= n; i++)
    {
        if(dis[i] == LONG_MAX)
        {
            cout << -1 << " ";
        }
        else
        {
            cout << dis[i] << " ";
        }
    }

    return 0;
}
```

## 时间复杂度分析

​	对于每个顶点，其实是把每个顶点的出边放到堆中，所以是遍历了所有边。而最坏情况下，所有边都需要进入堆中，整体时间复杂度就是m*logm，m为总边数。

​	对于空间复杂度，存图开销加上堆的开销。

## 练习题目

​	https://www.luogu.com.cn/problem/P4779

​	https://leetcode.cn/problems/swim-in-rising-water/

## 反向堆索引优化

​	m*logm的时间复杂度已经够优秀了，用该算法即可应付所有情况。至于最优解，应该是m*logn的，但由于logn和logm相差不大，且反向堆索引需要自己手写堆，增加一个反向索引功能，让在堆中的点的距离可以被更新掉，而不是无脑加，这样就可以使得堆的规模只与顶点数量有关，从而做到优化。有余力同学自行研究学习。

## 分层图最短路

​	相比于之前的最短路，分层图最短路实际上是将实际位置加上一些状态信息来表示位置，最明显的特征就是同一个格子可以被经过多次，由于状态不同。加上该信息去跑bfs或者最短路就可以了。

## 练习题目

​	BFS：https://leetcode.cn/problems/shortest-path-to-get-all-keys/

​	Dijkstra：https://leetcode.cn/problems/DFPeFJ/

​	Dijkstra：https://www.luogu.com.cn/problem/P4568