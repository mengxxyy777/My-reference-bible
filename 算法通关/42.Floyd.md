# Floyd

​	Floyd是一个比较简单暴力的算法，它的时间复杂度为O(n^3)，空间复杂度为O(n^2)。

​	核心思想是枚举所有中间点，看看dis[u] [v] 能不能被这个中间点更新掉，也就是： 

​	dis[u] [v] = min(dis[u] [v], dis[u] [bridge] + dis[bridge] [v]);

​	Floyd通过填写这张二维表就可以实现任意两点间的最短距离可求了，边权可以为负，但是不能有负环。

## 例子

​	![image-20250102205611233](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250102205611233.png)

## 核心代码

```cpp
// 假设图已经建好，边权存在dis数组中
void floyd()
{
    // 先枚举每一个中间点，看能不能更新结果
    for(int k = 0; k < n; k++)
    {
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                // i到k以及k到j需要有路，才能更新最短路
                if(dis[i][k] != INT_MAX && dis[k][j] != INT_MAX &&
                   dis[i][j] > dis[i][k] + dis[k][j])
                {
                    dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
}
```

## 练习题目

​	https://www.luogu.com.cn/problem/P2910