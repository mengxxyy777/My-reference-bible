# Bellman-Ford

​	是一种单源最短路算法。

​	适用条件：可以有负边，不能有负环。

## 松弛操作

​	松弛操作是说源点到点F的距离记为dis[F]，如果有一条边终点为F，假如P->F有一条权值为w的边，如果dis[P] + w < dis[F]，我们让dis[F] = dis[P] + w，这时我们就说点P对点F进行了松弛操作。

## 算法流程

​	遍历所有边，判断所有边能否进行松弛操作，如果能，则更新；

​	遍历一次所有边记为一轮，重复操作直到所有边都不能进行松弛操作为止。

​	时间复杂度为O(n*m)，n为点数，m为边数。

​	看起来很傻，但是可以被SPFA优化。

## 图解

![image-20250103121834270](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250103121834270.png)

## 算法推广

​	Bellman-Ford算法可以判断图中从某个点出发是否有负环，当轮数来到n轮时，就说明图中有负环。

## 练习题目

```cpp
class Solution
{
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k)
    {
        vector<int> dis(n, INT_MAX);
        dis[src] = 0;
        for(int i = 0; i <= k; i++)
        {
            vector<int> nex = dis;
            for(auto edge : flights)
            {
                int u = edge[0];
                int v = edge[1];
                int w = edge[2];
                if(dis[u] != INT_MAX)
                {
                    nex[v] = min(nex[v], dis[u] + w);
                }
            }
            dis = nex;
        }

        return dis[dst] == INT_MAX ? -1 : dis[dst];
    }
};
```

