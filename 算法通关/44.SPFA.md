# SPFA

​	SPFA（Shortest Path Faster Algorithm）是用来优化Bellman-Ford算法的。朴素的Bellman-Ford算法每轮都需要遍历所有边，但其实做了很多无用功，我们在下一轮应该只关心那些在当前轮被松弛过的那些点。

​	拿来一个bool数组，记录当前轮更新过的点，那么在下一轮只需要看这些点即可。在队列中就标true，否则标false。SPFA的时间复杂度仍为O(n*m)，只不过大量优化了常数时间，在小图、边权有负、无负环的情况下，速度还是很快的。

​	SPFA比较重要的内容是解决费用流的问题。

## 模板练习题

​	模板+负环判断：https://www.luogu.com.cn/problem/P3385

## code

```cpp
#include <iostream>
#include <limits.h>
using namespace std;

#define MAXN 2005
#define MAXM 6005

int t;
int n, m;

int head[MAXN];
int nex[MAXM];
int to[MAXM];
int wei[MAXM];
int cnt;

void addedge(int u, int v, int w)
{
    nex[cnt] = head[u];
    to[cnt] = v;
    wei[cnt] = w;
    head[u] = cnt++;
}

int dis[MAXN];
int queue[4000001];
bool vis[MAXN];
int upcnt[MAXN];
int l, r;

bool spfa()
{
    dis[1] = 0;
    vis[1] = true;
    queue[r++] = 1;
    upcnt[1]++;
    int f = 0;
    while(l < r)
    {
        int u = queue[l++];
        vis[u] = false;
        for(int e = head[u]; e != 0; e = nex[e])
        {
            int v = to[e];
            int w = wei[e];
            if(dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                if(!vis[v])
                {
                    if(++upcnt[v] > n-1)
                    {
                        return true;
                    }
                    queue[r++] = v;
                    vis[v] = true;
                }
            }
        }
    }
    
    return false;
}

int main()
{
    ios::sync_with_stdio(false);
	cin.tie(nullptr);
    cin >> t;
    while(t--)
    {
        l = r = 0;
        cnt = 1;
        for(int i = 0; i < MAXN; i++)
        {
            head[i] = 0;
            vis[i] = false;
            upcnt[i] = 0;
            dis[i] = INT_MAX;
        }
        
        cin >> n >> m;
        int u, v, w;
        for(int i = 0 ; i < m; i++)
        {
            cin >> u >> v >> w;
            if(w >= 0)
            {
                addedge(u, v, w);
                addedge(v, u, w);
            }
            else
            {
                addedge(u, v, w);
            }
        }
        
        if(spfa())
        {
            cout << "YES" << endl;
        }
        else
        {
            cout << "NO" << endl;
        }
    }
    
    return 0;
}
```

