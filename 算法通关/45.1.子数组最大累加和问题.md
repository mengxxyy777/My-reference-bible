# 子数组最大累加和

## 经典问题

​	给出一个数组arr，求出子数组的和中最大的和。

​	arr：[5, -2, 3, -9, 4, -1, 3, 1, -9, 4]

​	我们可以知道，以任意一个位置结尾的子数组的最大和是什么，一定是前一个位置的最大和加上当前位置元素，与当前位置元素，二者中的最大值。

​	定义dp[i]为以i结尾的子数组的最大和，那么状态转移方程如下：

```cpp
dp[i] = max(dp[i - 1] + a[i], a[i]);
```

## 空间压缩

```cpp
pre = max(pre + nums[i], nums[i]);
ans = max(ans, pre);
```

## 附加问题

​	在上面基础上，不仅返回和，还要返回区间左右下标。

​	这时，在空间压缩的版本下，我们每来到一个位置，都会有两种选择：

​		1）只选当前位置；

​		2）加上前一个位置的最优解。

​	我们准备l, r, pre三个变量，用于记录当前区间的左右下标以及当前最大累加和。

​	当命中第一种情况时，说明前方的最优解加当前元素不会使得结果更优，也就是pre < 0，这个时候，区间左侧需调整到当前位置r；

​	当命中第二种情况时，说明前方的最优解加当前元素会使得结果更优，也就是pre >= 0，此时，区间左侧不动，右侧右移。

​	无论命中那种情况，我们需要比较当前最优解pre与全局最优解ans，如果pre更大，说明当前区间到目前为止，是最优解，我们把 l 和 r 更新到全局答案 left 和 right 中，最后记录的left、right、ans即为所需结果。

## 练习题目

​	模板题：https://leetcode.cn/problems/maximum-subarray/

​	https://leetcode.cn/problems/maximum-sum-circular-subarray/

​	https://leetcode.cn/problems/maximum-product-subarray/

​	https://leetcode.cn/problems/house-robber/description/

​	https://leetcode.cn/problems/house-robber-ii/

​	https://leetcode.cn/problems/house-robber-iv/

​	矩阵压缩：https://leetcode.cn/problems/max-submatrix-lcci/

​	https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/

## 大厂笔试真题

​	1.子序列累加和必须被7整除的最大累加和，nums[i]非负。

​		这是一道二维dp的题目，第二维定义余数来约束。

​	2.给定一个数组nums，两个魔法卷轴，每个魔法卷轴可以把数组的一段变为0。现希望数组的整体累加和尽可能大，卷轴使用与否、使用多少随意，请返回数组尽可能大的和。

​		分情况讨论，ans = max(不适用魔法卷轴，只用一次魔法卷轴，用两次魔法卷轴)。

​	3.可以翻转一次的情况下子数组的最大累加和。

​		枚举一侧，计算每个位置结束的子数组的最大累加和，再找另一侧的子数组最大累加和，加一起就行了，因为另一侧的该最大和的子数组总能反转过来。

​	4.删掉一个数字后长度为k的子数组最大累加和。

​		转化为求原数组中长度为k+1的子数组的和减去该区间最小值，得到的结果pk出最大值即为答案。区间最小值由单调队列维护。