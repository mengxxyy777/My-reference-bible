# 最长递增子序列问题

​	题目链接：https://leetcode.cn/problems/longest-increasing-subsequence/

## 思路、解决方法

​	给出一个数组nums，返回严格递增的最长的子序列长度。

​	让dp[i]表示以i结尾的最长递增子序列的长度，那么很容易想到，我们需要找到[0, i-1]上所有比nums[i]小的元素中，最长的子序列长度，再加上i位置的1长度即可。

​	时间复杂度为O(n^2)，空间复杂度O(n)，n为nums的长度。

## 核心code

```cpp
for(int i = 0; i < n; i++)
{
	dp[i] = 1;
	for(int j = 0; j < i; j++)
	{
		if(nums[j] < nums[i])
		{
			dp[i] = max(dp[i], dp[j] + 1);
		}
	}
	ans = max(ans, dp[i]);
}
```

## 优化

​	我们加入一个ends数组，ends[i]表示长度为i+1的子序列的最小结尾。ends数组可以帮助我们加速dp的求解过程。

​	来到一个位置nums[i]时，在ends数组中二分查找大于等于nums[i]的最左位置，将该位置的值替换为nums[i]，然后dp[i]的值就是ends数组中该位置算自己加左边元素的个数。

​	易知，ends数组的作用就是维护各个递增子序列的最小结尾，ends数组中最后剩了几个元素，那么他的长度一定对应着最长递增子序列的长度；同时ends数组为严格递增；ends数组中最后剩的元素个数为最长递增子序列的长度，但是内容上不一定是该子序列。

​	我们需要遍历一遍数组，在每个位置上在ends数组二分找到大于等于nums[i]的位置，故优化后的整体时间复杂度为O(n*logn)，空间复杂度为O(n)。

## 优化后核心code

​	其中bs函数是在ends[0, ind-1]上二分，找到大于等于nums[i]的最左位置，返回下标；如果没找到就返回-1。

```cpp
for(int i = 0; i < n; i++)
{
	dp[i] = 1;
	int pos = bs(ends, 0, ind, nums[i]);
	if(pos == -1)
	{
		ends[ind++] = nums[i];
	}
	else
	{
		ends[pos] = nums[i];
	}
}
```

## 扩展：最长不降子序列

​	不要求严格递增，那么在上述代码查找时，原来是大于等于nums[i]的最左位置，现在只需找到大于nums[i]的最左位置即可。

## 练习题目

​	https://leetcode.cn/problems/russian-doll-envelopes/

​	https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/

​	https://leetcode.cn/problems/maximum-length-of-pair-chain/

​	难题：https://www.luogu.com.cn/problem/P8776