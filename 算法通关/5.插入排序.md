# 插入排序

​	插入排序是一种**比较排序**，是最简单的排序算法之一。

## 何为插入排序？

​	插入排序就是逐个遍历待排序集合，将当前元素插入到已排序集合的正确位置。

​	我们学过本节之后也可以发现，插入排序与选择排序很相似，只不过选择排序是在待排序元素中遍历，插入排序是在已排序元素中遍历。

## 插入排序过程

​	给定一个长度为6的数组，下标从0开始：[1, 4, 6, 3, 5, 2]。

​		所有元素都是待排序元素，那就从第一个元素遍历到最后一个元素。

​		第一步，选择1，插入到已排序集合中：[**1**, 4, 6, 3, 5, 2]。

​		第二步，选择4，我们发现需要插入在1后面：[**1, 4**, 6, 3, 5, 2]。

​		第三步，选择6，与上一步类似：[**1, 4, 6**, 3, 5, 2]。

​		第四步：选择3，发现需要插入到1和4之间：[**1, 3, 4, 6**, 5, 2]。

​		第五步：选择5，发现需要插入到4和6之间：[**1, 3, 4, 5, 6**, 2]。

​		第六步：选择2，发现需要插入到1和3之间：[**1, 2, 3, 4, 5, 6**]。

​		数组就排好序了。

​	代码非常简单。

## code

```cpp
#include <iostream>
using namespace std;

int n;
int a[105];

void insertSort()
{
	// 对于每个待排序元素 
	for(int i = 1; i < n; i++)
	{
		// 暂存当前元素 
		int temp = a[i];
		int j;
		// 依次向前找，找到第一个小于当前元素的值 
		for(j = i-1; j >= 0; j--)
		{
			if(temp < a[j])
			{
				a[j+1] = a[j];
			}
			else
			{
				break;
			}
		}
		// 插入到所找值的后边 
		a[j+1] = temp;
	}
}

int main()
{
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	insertSort();
	
	for(int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}
	
	return 0;	
} 
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	遍历所有元素，并给每个元素都找到一个合适的位置插入，实际上整个**时间复杂度是O(n^2)**的，感兴趣的同学自行证明。

### 	空间复杂度

​	不需要额外的辅助空间，所以**空间复杂度为O(1)**。

## 小结

### 	稳定性

​	小于等于即为要找的位置，实际上相同元素的相对位置并没有改变。反之则不稳定。

### 	原地排序

​	不需要额外空间

### 	优点

​	简单易实现，容易理解，数据量小的时候有着不错的表现。

### 	缺点

​	时间复杂度不好，在面对较大数据量的时候跑不动。

## 插入排序的优化

（*注：此处部分内容属于进阶内容，看不懂也没关系，后续会讲到*）

​	插入排序每次需要在有序数组中找到合适的位置，这个过程可以用二分查找，将该过程的时间复杂度降为O(logn)。

​	此处优化部分待更新……