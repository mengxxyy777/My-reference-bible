# 质数

​	质数也叫素数，是除了1和本身外，没有其他的因数的数字。2是最小的质数，同时也是唯一一个偶数质数。素数的研究对于数学的研究有着重要的作用。

## 质数判断

​	计算机中如何去判断一个数是不是质数？很简单，从2开始到n-1分别试，如果n对他们取模为0，则不是质数；反之是质数。时间复杂度为O(n)。

### code

```cpp
bool isprime(int n)
{
	if(n == 0 || n == 1)
	{
		return false;
	}
	else if(n == 2)
	{
		return true;
	}
	else
	{
		for(int i = 2; i < n; i++)
		{
			if(n % i == 0)
			{
				return false;
			}
		}
		return true;
	}
}
```

### 枚举优化

​	观察到上述时间复杂度，当n较大时需要花费O(n)的代价判断，速度较慢，如何优化枚举呢？其实我们只需要枚举到n的平方根即可，向下取整。

### 优化code

```cpp
bool isprime(int n)
{
	if(n == 0 || n == 1)
	{
		return false;
	}
	else
	{
		for(int i = 2; i * i <= n; i++)
		{
			if(n % i == 0)
			{
				return false;
			}
		}
		return true;
	}
}
```

### 大数质数判断

​	本判断方法是Miller Rabin算法，详细证明较为复杂，请自行了解。

​	模板题：https://www.luogu.com.cn/problem/U148828

### code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef __int128 ll;
typedef pair<int, int> pii;

template<typename T> inline T read()
{
    T x = 0, f = 1; char ch = 0;
    for(; !isdigit(ch); ch = getchar())
    {
        if(ch == '-') f = -1;
    }
    for(; isdigit(ch); ch = getchar())
    {
        x = (x << 3) + (x << 1) + (ch - '0');
    }
    return x * f;
}

template<typename T> inline void write(T x)
{
    if(x < 0)
    {
        putchar('-'), x = -x;
    }
    if(x > 9)
    {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}

template<typename T> inline void print(T x, char ed = '\n')
{
    write(x), putchar(ed);
}

ll t, n;

ll qpow(ll a, ll b, ll mod)
{
    ll ret = 1;
    while(b)
    {
        if(b & 1)
        {
            ret = (ret * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ret % mod;
}

vector<ll> p = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};

bool miller_rabin(ll n)
{
    if(n < 3 || n % 2 == 0)
    {
        return n == 2;
    }
    ll u = n - 1, t = 0;
    while(u % 2 == 0)
    {
        u /= 2, ++t;
    }
    for(auto a : p)
    {
        if(n == a)
        {
            return 1;
        }
        if(n % a == 0)
        {
            return 0;
        }
        ll v = qpow(a, u, n);
        if(v == 1)
        {
            continue;   
        }
        ll s = 1;
        for(; s <= t; ++s)
        {
            if(v == n - 1)
            {
                break;   
            }
            v = v * v % n;
        }
        if(s > t)
        {
            return 0;   
        }
    }
    return 1;
}

int main()
{
    t = read<ll>();
    while(t--)
    {
        n = read<ll>();
        if(miller_rabin(n))
        {
            puts("Yes");
        }
        else
        {
            puts("No");
        }
    }
    return 0;
}
```

## 质因子分解

​	从2试到n的平方根，不断除最小的质数，最后剩下的如果大于1，也是质数。

​	有兴趣可以继续研究pollard_rho启发式方法分解质因数，上面的方法时间上也够优秀了，此处不再赘述。

### code

```cpp
void f(int n)
{
	for(int i = 2; i * i <= n; i++)
	{
		if(n % i == 0)
		{
			cout << i << " ";
			while(n % i == 0)
			{
				n /= i;
			}
		}
	}
	if(n > 1)
	{
		cout << n;
	}
}
```

### 练习题目

​	质因子分解+并查集：https://leetcode.cn/problems/largest-component-size-by-common-factor/

## 质数筛

​	质数筛就是筛选出1-n上所有的质数。

### 埃氏筛

​	首先先认为0-n所有的数字都是质数，质数标记为0，合数标记为1。

​	我们每次只处理质数，也就是为0的数字。从2到n，假如来到i位置，i为质数，那么从i*i开始，i * (i + 1)...一直到不超过n即可，都标记为合数。

​	时间复杂度：O(n * log (logn) )。证明此处略。

### 埃氏筛code

```cpp
for(int i = 2; i <= n; i++)
{
	if(!vis[i])
	{
		for(int j = i * i; j <= n; j += i)
		{
			vis[j] = 1;
		}
	}
}
```

### 欧拉筛

​	欧拉筛优化了埃氏筛反复设置同一个合数的问题。新增一个质数数组，收集遇到的每一个质数，在设置合数的过程中，只由其最小的质因子来设置，具体看代码理解。时间复杂度O(n)，但是常数时间不如埃氏筛，掌握埃氏筛足够了。

### 欧拉筛code

```cpp
for(int i = 2; i <= n; i++)
{
	if(!vis[i])
	{
		prime[cnt++] = i;
	}
	for(int j = 0; j < cnt; j++)
	{
		// 越界位置 
		if(i * prime[j] > n)
		{
			break;
		}
		vis[i * prime[j]] = true;
		// 下面的判断保证了每个合数只由自己最小的质数来设置 
		if(i % prime[j] == 0)
		{
			break;
		} 
	}
}
```

### 练习题目

​	https://leetcode.cn/problems/count-primes/

### 埃氏筛的改进

​	如果只是计数，埃氏筛可以优化。先估计质数的个数，遇到合数减去就行了。

### code

```cpp
int ehrlich(int n)
{
	if(n <= 1)
	{
		cout << 0;
		return 0;
	}
	int cnt = (n + 1) / 2;
	for(int i = 3; i * i <= n; i += 2)
	{
		if(!vis[i])
		{
			for(int j = i * i; j <= n; j += 2 * i)
			{
				if(!vis[j])
				{
					vis[j] = true;
					cnt--;
				}
			}
		}
	}
	return cnt;
}
```

