# 乘法快速幂、矩阵快速幂

## 乘法快速幂

​	求a的b次方，可能很大，模p。

​	模板题：https://www.luogu.com.cn/problem/P1226

​	将b转化为二进制形式，a每次自己乘自己，看该位信息是否为1即可。

### code

```cpp
long long quickpower(long long a, long long b)
{
    long long ans = 1;
    while(b > 0)
    {
        if(b & 1)
        {
            ans = ans * a % p;
        }
        a = a * a % p;
        b >>= 1;
    }
    return ans;
}
```

## 矩阵快速幂

### 矩阵乘法

​	用前面矩阵的每一行分别乘以后面矩阵的每一列，得到的结果填到对应的行号列号上。

​	同时矩阵也可以求幂，这个时候为了保证能一直乘下去，需要行列数量相等。

### 演示code

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<vector<int>> a = {{2, 4}, {3, 2}};
	vector<vector<int>> b = {{2, 3, 2}, {3, 2, 3}};
	
	int n = a.size();
	int m = b[0].size();
	int t = a[0].size();
	for(int i = 0; i < n; i++)
	{
		for(int j = 0; j < m; j++)
		{
			int ans = 0;
			for(int k = 0; k < t; k++)
			{
				ans += a[i][k] * b[k][j];
			}
			cout << ans << " ";
		}
		cout << endl;
	}
	
	return 0;
} 
```

### 矩阵快速幂

​	和乘法快速幂一样的，只不过变成了二维矩阵相乘，代码在上面。其中的ans = 1，我们需要将ans设置为二维矩阵中的1，也就是单位矩阵。

​	我们用mul方法将上方演示code封装为一个方法，供我们下面使用。

### code

```cpp
vector<vector<int>> mul(vector<vector<int>>& a, vector<vector<int>>& b)
{
	int n = a.size();
	int m = b[0].size();
	int t = a[0].size();
	vector<vector<int>> ans(n, vector<int>(m));
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			for (int k = 0; k < t; k++)
			{
				ans[i][j] += a[i][k] * b[k][j];
			}
		}
	}
	return ans;
}

vector<vector<int>> matrixquickpower(vector<vector<int>>& a, int p)
{
	int n = a.size();
	vector<vector<int>> ans(n, vector<int>(n));
	for (int i = 0; i < n; i++)
	{
		ans[i][i] = 1;
	}

	for (; p != 0; p >>= 1)
	{
		if (p & 1)
		{
			ans = mul(ans, a);
		}
		a = mul(a, a);
	}
	return ans;
}
```

## 优化固定关系的一维多阶递推表达式

​	一定有一个k阶的固定行列式，通过不断乘该行列式得到后续项。例如，对于斐波那契数列，这个固定关系的矩阵为：{{1, 1}, {1, 0}}。该矩阵第一列的值由递推关系的系数确定，其他的由一些初始项确定。这样每次求第n项实际上就是乘以该矩阵n-1次，初始矩阵可以用斐波那契数列的第0项和第1项。

### 练习题目

​	https://leetcode.cn/problems/fibonacci-number/

​	https://leetcode.cn/problems/climbing-stairs/

​	https://leetcode.cn/problems/n-th-tribonacci-number/

​	https://leetcode.cn/problems/domino-and-tromino-tiling/

## 优化固定关系的多维一阶递推表达式

​	该优化中，关系矩阵的求法比上面简单一些。

### 练习题目

​	https://leetcode.cn/problems/count-vowels-permutation/

​	https://leetcode.cn/problems/student-attendance-record-ii/