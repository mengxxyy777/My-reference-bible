# KMP算法

​	KMP算法解决的是字符串匹配问题，朴素算法是每个位置撸一遍要找的串，时间复杂度为O(n * m)。KMP算法可以将这个时间复杂度降为O(n + m)，比较妙。

## next数组定义

​	我们需要对要找的子串（后面就说s2了，在s1里面找）求一个next数组。next数组的含义是：不含当前位置，前面字符串的前缀和后缀最大匹配长度，同时前面字符串不能是整体，因为前缀和后缀是相同的，对于算法来说没有意义。next[0] = -1，next[1] = 0。

## next数组如何加速串匹配

​	1）跳过没用的开头比对；

​	2）跳过没用的前缀比对。

![image-20250205085209180](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250205085209180.png)

## 如何求解next数组

​	需要看当前位置的前一个位置的next值对应的下标上的字符，是否跟当前前一个位置字符相同，如果相同就是前一个位置next值加1，不然就需要不断地根据next数组的值向下跳，去比对。

## code

```cpp
#include <iostream>
#include <string>
using namespace std;

int nex[105];

void getnex(string s, int m)
{
	nex[0] = -1;
	nex[1] = 0;
	int i = 2, cn = 0;
	while (i < m)
	{
		if (s[i - 1] == s[cn])
		{
			nex[i++] = ++cn;
		}
		else if (cn > 0)
		{
			cn = nex[cn];
		}
		else
		{
			nex[i++] = 0;
		}
	}
}

int kmp(string s1, string s2)
{
	int n = s1.size();
	int m = s2.size();
	int x = 0, y = 0;
	getnex(s2, m);
	while (x < n && y < m)
	{
		if (s1[x] == s2[y])
		{
			x++;
			y++;
		}
		else if (y == 0)
		{
			x++;
		}
		else
		{
			y = nex[y];
		}
	}
	return y == m ? x - y : -1;
}

int main()
{
	string s1 = "abcabctabcabcs";
	string s2 = "abct";

	cout << kmp(s1, s2);

	return 0;
}
```

## 时间复杂度

​	在求解next数组时，观察到 i 与 i - cn变量要么不变，要么++，故时间复杂度为O(m)。

​	在kmp过程，x 与 x - y要么不变，要么++，故时间复杂度为O(n)。

​	故KMP算法的时间复杂度为O(n + m)。

## 总结

​	KMP算法精髓在于next数组，可以将O(n * m)的过程优化到O(n + m)。

​	但是next数组在很多问题中都有应用，待遇到时会更能体会到精妙的地方。

## 练习题目

​	模板题：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/

​	https://leetcode.cn/problems/subtree-of-another-tree/

​	https://www.luogu.com.cn/problem/P4391

​	利用栈模拟字符串删减操作：https://www.luogu.com.cn/problem/P4824

​	在树上利用s2的next数组加速匹配：https://leetcode.cn/problems/linked-list-in-binary-tree/

​	数位dp + KMP优化子串查询：https://leetcode.cn/problems/find-all-good-strings/