# 马拉车算法

​	马拉车算法最经典的应用是解决最长回文子串。但是这也只是微不足道的应用，灵活运用回文半径数组，能帮助我们解决很多更难的问题。

## 暴力方法求最长回文子串

​	枚举每个位置，以每个位置为中心向两边扩，时间复杂度O(n^2)，并且会错过偶数长度的回文串。

​	我们可以在原始字符串的两头以及相邻两字符中间插入一个元素无关紧要的字符，例如 ‘#’，这样暴力展开每个位置。扩展出来的串的长度为2*n + 1。

## 回文半径

​	定义回文半径为：回文串中心字符到其中一边的距离，算上本身。例如：“#a#b#a#”，该回文串长度为7，那么回文半径就为4，其实也就是一半的回文串长度加上中心字符长度1。

​	这样，我们发现，原始字符串中回文子串的长度就是对应位置的回文半径减一。例如上面的例子，原始字符串应为“aba”，长度为3；b的回文半径为4。

​	每个位置生成这样一个回文半径，形成一个回文半径数组。

​	还有对应关系：扩展串的回文串的结尾位置 / 2，对应着原始回文串的结尾的下一个位置。

​	方便求解，但是时间复杂度并没有优化。

## 马拉车算法核心

​	用马拉车来加速这上述过程。

​	有一个回文半径数组p，是我们要求的。准备一个回文覆盖最右边界r，以及回文中心c，c记录最左的能扩到r的位置。

​	i为从左到右扩展串的下标，我们逐个遍历。来到一个位置时，分情况：

​		a）r没包住i，这时按照暴力展开即可，并不能加速该过程；

​		b）i被r包住，以i位置关于c的对称点2*c-1为中心的回文串整体在以c为中心的回文区域内，这时p[i] = p[2 * c - 1]；

​		c）i被r包住，以i位置关于c的对称点2*c-1为中心的回文串整体跨过了以c为中心的回文区域，这时p[i] = r - i；

​		d）i被r包住，以i位置关于c的对称点2*c-1为中心的回文串边界与以c为中心的回文区域边界重合，此时需要将以i为中心的回文区域，回文半径至少为r - i，需要进一步向两边扩充。

​	马拉车算法优化过程直接将时间复杂度降为O(n)。在a和d两种可能多次操作的情况中，r一直在增加，并不回退。

## code

```cpp
#include <iostream>
#include <string>

using namespace std;

// 原始字符串、处理过后的字符串
string s, ss;

// 回文半径数组，注意要开两倍的长度，因为处理过后的字符串长度为2*n + 1
int p[22000005];

void stoss()
{
	ss = "#";
	for(int i = 0; i < s.size(); i++)
	{
		ss += s[i];
		ss += '#';
	}
}

int manacher()
{
	int n = ss.size();
	int ans = 0;
	for(int i = 0, r = 0, c = 0, len; i < n; i++)
	{
		// 当前以c为中心、r为右边界的回文区域
		// 先能找到一个至少得回文区域长度
		len = r > i ? min(p[2 * c - i], r - i) : 1;

		// 如果命中b情况和c情况，while不能执行
		// 只有d情况需要扩展才去走while
		while(i + len < n && i - len >= 0 && ss[i + len] == ss[i - len])
		{
			len++;
		}

		// 及时更新回文最右覆盖边界和回文中心，给下一次的i用
		if(i + len > r)
		{
			r = i + len;
			c = i;
		}
		ans = max(ans, len);
		p[i] = len;
	}

	return ans - 1;
}

int main()
{
	cin >> s;
	stoss();
	cout << manacher();

	return 0;
}
```

## 练习题目

​	模板题：https://www.luogu.com.cn/problem/P3805

​	模板题+：https://leetcode.cn/problems/longest-palindromic-substring/

​	模板题+：https://leetcode.cn/problems/palindromic-substrings/

​	https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/

​	https://www.luogu.com.cn/problem/P1659

​	https://www.luogu.com.cn/problem/P4555

# 扩展KMP

​	扩展KMP其实与KMP关系不大，反而需要马拉车算法的思想。国外直接就叫Z algorithm，所以我们可以称之为z函数或者z算法。

​	给定一个字符串s，z[i]表示在s中，从i位置出发的字符串，与s整体有多长的公共前缀。

## 求解Z数组

​	很显然，z[0] = s.size()；

​	对于一个普遍的位置i，我们还需要c和r，r表示与马拉车一样，i出发匹配0出发，一直到匹配不上的位置记为r；c表示略有不同，c在马拉车表示中心，在扩展KMP表示某个开头开始，去匹配。在马拉车算法中有一个关键点2*c-i，是i关于c的对称点，扩展KMP这个关键点是i-c，i-c向后能扩多长，i位置就扩多长。

​	分情况也同马拉车，i位置扩出去在c位置扩出去的范围内、范围外、以及正好在边界上。r与c的更新同马拉车算法。接下来讨论各种情况：

​		a）如果没被包住，逐个向后扩展；

​		b）在范围内的时候，z[i] = z[i-c]，就是一个简单的传递关系；

​		c）在范围外的时候，z[i] = r - i，证明同上；

​		d）在边界上时，区域内一定是可以匹配的长度，区域之外需要逐个展开，向后扩展。

​	太像了！简直就是马拉车算法的翻版。所以扩展KMP与KMP没什么关系，其实与马拉车算法有关系！

​	时间复杂度同马拉车算法，为O(n)。

## code

```cpp
// 记录答案，z[i]表示从i开始的后缀串与s整体的最大公共前缀的长度
int z[20000005];

// 求解字符串s的Z数组，s的长度为m
void zarr(string s, int m)
{
	z[0] = m;
    // 从1位置开始
	for(int i = 1, c = 1, r = 1, len; i < m; i++)
	{
        // 无论哪种情况，至少的匹配前缀长度
		len = r > i ? min(r - i, z[i - c]) : 0;
        // 针对于a和d情况，逐个向后遍历扩展r
		while(i + len < m && s[i + len] == s[len])
		{
			len++;
		}
		if(i + len > r)
		{
			r = i + len;
			c = i;
		}
		z[i] = len;
	}
}
```

## 求解e数组

​	思想同马拉车、Z数组。

​	给定两个字符串A、B，e[i]表示：A字符串从i位置开始，与B整体的最长公共前缀。

​	需要先求出B数组的Z数组，一样的传递关系，此处省略分析。

## code

```cpp
int z[20000005];
int e[20000005];

// 此时已经求出b的z数组了
// 也就是zarr(b, m)已经执行过了，答案保存在z数组中，下面直接用
// 求e数组，e[i]表示a从i位置出发的后缀串，与b整体最大匹配前缀长度
void earr(string a, string b, int n, int m)
{
	for(int i = 0, c = 0, r = 0, len; i < n; i++)
	{
        // 无论哪种情况，至少的匹配前缀长度
		len = r > i ? min(r - i, z[i - c]) : 0;
        // 此时如果要扩展，需要比较的是a与b字符串对应位置是否相等
		while(i + len < n && len < m && a[i + len] == b[len])
		{
			len++;
		}
		if(i + len > r)
		{
			r = i + len;
			c = i;
		}
		e[i] = len;
	}
}
```

## 练习题目

​	模板题：https://www.luogu.com.cn/problem/P5410

​	Z数组的简单应用：https://leetcode.cn/problems/minimum-time-to-revert-word-to-initial-state-ii/