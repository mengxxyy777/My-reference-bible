# 树状数组

​	树状数组（IndexTree）是一种比较重要的数据结构，支持一系列操作。

​	树状数组一般情况下用来维护可差分的信息。不可差分的信息交给线段树来解决。

## 可差分的信息

​	什么是可差分的信息呢？比如累加和数组、累乘积数组等，知道了总体，知道其中一部分，可以直接求出剩下的部分。

## 不可差分的信息

​	最大值、最小值等。

## 树状数组的功能

### 一维数组

#### 单点增加、范围查询

​	模板题：https://www.luogu.com.cn/problem/P3374

​	怎样维持一个树状数组呢？这个数组和原始数组等长，且下标都从1开始。分别分组，长度以2的某次方。对应树状数组中下标i负责的区间，就是原始数组中i占的所有分组中，i位于最右边且最长的组，树状数组中i下标就负责维护这段信息。

​	那么如何知道树状数组中的下标i负责哪段区间呢？该区间的右边界一定是i本身，左边界就是i将最右边的1变成0再加1。

​	范围查询query方法应该如何实现呢？我们只需要求下标1到i范围的累加和即可。先将i位置在树状数组中的值拿出来，然后去掉i二进制下最右侧的1，再去累加，直到i变为0。

​	对于单点增加方法add，树状数组中不止一个位置负责i下标，所以要不断加上i最右侧的1，这些下标就是负责的区间有i的位置。

​	单次调用时间复杂度为O(logn)。

##### 如何求出一个数字最右侧的1？

```cpp
int lowbit(int i)
{
	return i & -i;
}
```

##### 如何单点增加？

```cpp
// 在下标i的位置加上x
// 需要考虑所有负责区间有i的位置，就是i不断加自己最右侧的1
void add(int i, int x)
{
	while(i <= n)
	{
		tree[i] += x;
		i += lowbit(i);
	}
}
```

##### 如何求[1，i]范围的和？

```cpp
// 需要不断拿去i最右侧的1
// 这样所有的tree[i]的区间囊括[1，i]
int sum(int i)
{
	int ans = 0;
	while(i > 0)
	{
		ans += tree[i];
		i -= lowbit(i);
	}
	return ans;
}
```

##### 如何求[l，r]范围的和？

```cpp
// 求[l, r]范围上的和
// 类似前缀和，同时下标从1开始，0位置默认是0，不需要考虑越界问题
int query(int l, int r)
{
	return sum(r) - sum(l - 1);
}
```

#### 范围增加、单点查询

​	模板题：https://www.luogu.com.cn/problem/P3368

​	此处利用原数组的差分数组来构建树状数组，这样范围增加可以变成两条单点增加，单点查询也就变成了[1, i]求和。代码处理差分数组的处理，和上面的没有区别。

#### 范围增加、范围查询

​	模板题：https://www.luogu.com.cn/problem/P3372

​	这个操作最经典的实现是线段树了，但是树状数组的常数时间要优于线段树。

​	因为范围增加需要差分数组，而要求原始[1, k]的和就需要在差分数组累加两次，简单推导过程如下：

![image-20250215091835473](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250215091835473.png)

​	此时我们需要两个树状数组来维持信息，除了增加时要增加两个树状数组的信息外，求和的时候注意，我们的sum需要用到上面的式子，将k变成r，再将k变成l-1，二者作差即为答案。

```cpp
// 求原数组中[l, r]的和，对比式子
ll sumsum(int l, int r)
{
	return sum(tree1, r) * r - sum(tree2, r) - sum(tree1, l - 1) * (l - 1) + sum(tree2, l - 1);
}
```

​	sum函数与之前写的一样，add函数需要指定哪个树状数组：

```cpp
void add(ll tree[], int i, ll x)
{
	while(i <= n)
	{
		tree[i] += x;
		i += (i & -i);
	}
}
```

​	每次范围[x, y]增加时，需要维护两个树状数组：

```cpp
add(tree1, x, k);
add(tree1, y + 1, -k);
add(tree2, x, (x - 1) * k);
add(tree2, y + 1, -(y * k));
```

### 二维数组

#### 单点增加、范围查询

​	模板题：https://leetcode.cn/problems/range-sum-query-2d-mutable/

​	与一维的相比，只拓展了维度，至于为什么这样做是对的，证明较为复杂，有兴趣的同学自行研究。

​	单点增加add方法：

```cpp
// 在下标(x, y)的位置加上v
void add(int x, int y, int v)
{
	for(int i = x; i <= n; i += (i & -i))
    {
        for(int j = y; j <= m; j += (j & -j))
        {
            tree[i][j] += v;
        }
    }
}
```

​	sum方法：

```cpp
(1, 1)到(x, y)范围上的和
int sum(int x, int y)
{
	int ans = 0;
	for(int i = x; i > 0; i -= (i & -i))
    {
        for(int j = y; j > 0; j -= (j & -j))
        {
            ans += tree[i][j];
        }
    }
	return ans;
}
```

#### 范围增加、范围查询

​	模板题：https://www.luogu.com.cn/problem/P4514

​	如何利用二维差分数组加工出原始数组中[1, 1]到[x, y]位置的和？

![image-20250215153226938](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250215153226938.png)

![image-20250215153238394](C:\Users\21702\AppData\Roaming\Typora\typora-user-images\image-20250215153238394.png)

​	此时注意到，我们需要维持的差分信息来到了四个。

​	之后就与上面的没什么区别了。二维树状数组单次调用时间复杂度为O(logn * logm)。

## 练习题目

​	值域树状数组：https://www.luogu.com.cn/problem/P1908

​	https://www.luogu.com.cn/problem/P1637

​	https://leetcode.cn/problems/number-of-longest-increasing-subsequence/

​	离线处理模板题：https://www.luogu.com.cn/problem/P1972

​	贪心+链式前向星+树状数组+逆序对数量（此题较难，未解决）：https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/
