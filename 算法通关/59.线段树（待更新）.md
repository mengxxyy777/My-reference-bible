# 线段树

## 开篇介绍

​	算法学习大致可以分为入门、进阶、高级、骨灰级别，算是从一个菜鸟到有经验的写手。线段树就是迈入高级阶段门槛的第一课，理解线段树，会使用线段树解决经典、复杂的问题，是算法学习路上的一个重要的里程碑。

## 简介

​	线段树可以维护的信息类型是：某节点的信息可以由O(1)的时间从子节点加工而来。满足的比如：最大值，最小值，累加和，累乘积等；不可维护的比如：范围上出现次数最多的数字等。

​	线段树的经典功能是范围查询和范围修改，单次调用时间复杂度为O(logn)。

## 线段树维护经典信息

### 累加和：范围增加、范围查询

​	首先有一个独立的数组，其次，给出的数据下标与该独立数组下标都是从1开始的。假设数据长度为n，那么线段树维护的独立的信息数组要开到4*n才必定够用。

#### 线段树的建立

​	建立该线段树需要不断找终点并且向下递归，直到叶子结点，也就是范围上只剩一个数字，l == r。下标统一从1开始，当前节点下标为i，左孩子下标就在i * 2，右孩子下标就在i * 2 + 1。

```cpp
void build(int l, int r, int i)
{
	if(l == r)
	{
		sum[i] = a[l];
	}
	else
	{
		int mid = (l + r) >> 1;
		build(l, mid, i << 1);
		build(mid + 1, r, i << 1 | 1);
		up(i);
	}
	tag[i] = 0;
}
```

#### 线段树的查询

​	假设已经建立好线段树了，想要查询某一段区间上的和，其实就是不断去左边右边找命中的区间，直到整个区间都加上。

```cpp
ll query(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return sum[i];
	}
	int mid = (l + r) >> 1;
	down(i, mid - l + 1, r - mid);
	ll ans = 0;
	if(mid >= wl)
	{
		ans += query(wl, wr, l, mid, i << 1);
	}
	if(mid < wr)
	{
		ans += query(wl, wr, mid + 1, r, i << 1 | 1);
	}

	return ans;
}
```

#### 线段树的修改及懒更新机制

​	这是线段树的核心，为什么叫懒更新呢？我们在修改时只需打上标记，在懒不住的时候才将信息下放，然后将懒信息清空，返回的时候注意要汇总，因为下面节点的值修改了，会影响到上面节点。

```cpp
void add(int wl, int wr, ll v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		lazy(i, v, r - l + 1);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(mid >= wl)
		{
			add(wl, wr, v, l, mid, i << 1);
		}
		if(mid < wr)
		{
			add(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}
```

```cpp
void lazy(int i, ll v, int c)
{
	sum[i] += v * c;
	tag[i] += v;
}
```

```cpp
void up(int i)
{
	sum[i] = sum[i << 1] + sum[i << 1 | 1];
}
```

```cpp
void down(int i, int ln, int rn)
{
	if(tag[i] != 0)
	{
		lazy(i << 1, tag[i], ln);
		lazy(i << 1 | 1, tag[i], rn);
		tag[i] = 0;
	}
}
```

#### 练习题目

​	模板题：https://www.luogu.com.cn/problem/P3372

### 累加和：范围重置、范围查询

​	与上方代码差的不多，懒更新时注意，值是直接改而不是累加，同时需要多加一个bool数组来界定某个区间是否有懒更新任务，只用0不能判断是否有任务更改了。

### 最大值：范围增加、范围查询

​	这个也与上面的没什么区别，注意up方法修改成取最大值而不是和，查询时注意也改成PK出最大值即可，同时懒更新时，如果一个区间都加上了v，那么该区间最大值也加上了v。

### 最大值：范围重置、范围查询

​	既然重置就还需要一个bool数组来控制是否有重置任务，重置时需要维护最大值变成重置值的大小，仅此而已。

### 累加和：范围重置、范围增加、范围查询

​	此时需要注意操作优先级的问题。

​	重置任务会将之前所有懒信息的影响都清空，因为重置了，此时累加懒信息变为0，重置懒信息就是重置值，累加和就是区间长度乘以重置值。

​	而累加任务是懒信息的增加，所以不需要清空。

​	接下来分析下发任务，既有重置任务，又有加任务。此时下放时需要先重置再加。因为如果既有重置任务，又有加任务，那么最后一次操作一定是加而不是重置，因为如果重置了，加信息一定为0，这也是上面为什么重置时将加信息清零。

### 最大值：范围重置、范围增加、范围查询

​	模板题：https://www.luogu.com.cn/problem/P1253

​	注意点同上，直接看AC代码：

```cpp
#include <iostream>
#include <limits.h>
using namespace std;

#define MAXN 1000005

typedef long long ll;

int n, q;
ll a[MAXN];
ll maxv[MAXN << 2];
ll add[MAXN << 2];
ll change[MAXN << 2];
bool update[MAXN << 2];

void up(int i)
{
	maxv[i] = max(maxv[i << 1], maxv[i << 1 | 1]);
}

void updatelazy(int i, ll v)
{
	maxv[i] = v;
	add[i] = 0;
	change[i] = v;
	update[i] = true;
}

void addlazy(int i, ll v)
{
	maxv[i] += v;
	add[i] += v;
}

void down(int i)
{
	if(update[i])
	{
		updatelazy(i << 1, change[i]);
		updatelazy(i << 1 | 1, change[i]);
		update[i] = false;
	}
	if(add[i] != 0)
	{
		addlazy(i << 1, add[i]);
		addlazy(i << 1 | 1, add[i]);
		add[i] = 0;
	}
}

void qjchange(int wl, int wr, ll v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		updatelazy(i, v);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i);
		if(mid >= wl)
		{
			qjchange(wl, wr, v, l, mid, i << 1);
		}
		if(mid < wr)
		{
			qjchange(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}

void qjadd(int wl, int wr, int v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		addlazy(i, v);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i);
		if(mid >= wl)
		{
			qjadd(wl, wr, v, l, mid, i << 1);
		}
		if(mid < wr)
		{
			qjadd(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}

ll query(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return maxv[i];
	}
	int mid = (l + r) >> 1;
	down(i);
	ll ans = LONG_MIN;
	if(mid >= wl)
	{
		ans = max(ans, query(wl, wr, l, mid, i << 1));
	}
	if(mid < wr)
	{
		ans = max(ans, query(wl, wr, mid + 1, r, i << 1 | 1));
	}
	return ans;
}

void build(int l, int r, int i)
{
	if(l == r)
	{
		maxv[i] = a[l];
	}
	else
	{
		int mid = (l + r) >> 1;
		build(l, mid, i << 1);
		build(mid + 1, r, i << 1 | 1);
		up(i);
	}
	add[i] = 0;
	change[i] = 0;
	update[i] = false;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> q;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	build(1, n, 1);
	ll x;
	for(int i = 1, op, l, r; i <= q; i++)
	{
		cin >> op;
		if(op == 1)
		{
			cin >> l >> r >> x;
			qjchange(l, r, x, 1, n, 1);
		}
		else if(op == 2)
		{
			cin >> l >> r >> x;
			qjadd(l, r, x, 1, n, 1);
		}
		else if(op == 3)
		{
			cin >> l >> r;
			cout << query(l, r, 1, n, 1) << "\n";
		}
	}

	return 0;
}
```

### 总结

​	void up(i...)：根据子范围的查询信息，把父范围的信息更新正确。

​	void down(i...)：父范围的懒信息，往下发放一层给左右子范围，然后清空父范围的懒信息。

​	void lazy(i...)：一段范围的整体被当前任务全覆盖时，或父范围下发的懒信息，直接懒住。

​	void build(l, r, i)：建树。

​	void qjchange(wl, wr, v, l, r, i)：[wl, wr]上所有值重置为v。

​	void qjadd(wl, wr, v, l, r, i)：[wl, wr]上所有值加v。

​	ll query(wl, wr, l, r, i)：[wl, wr]上查询任务。

## 线段树的离散化

​	对于一些并不在意数值且数值较大的区间，可以先离散化再求解。

### 练习题目

​	https://leetcode.cn/problems/falling-squares/

## 线段树+二分搜索

​	可以在某些过程用二分来加快某个O(n)的过程。

### 练习题目

​	https://acm.hdu.edu.cn/showproblem.php?pid=4614

## 线段树上的特别修改

​	区间内每个数字开平方，势能分析：https://www.luogu.com.cn/problem/P4145

​	区间内每个数字取模，势能分析：https://codeforces.com/problemset/problem/438/D

## 练习题目

​	离散化 + 中点插入 + 一次查询：https://www.luogu.com.cn/problem/P3740

## 线段树维护更多类型的信息

### 练习题目

​	https://www.luogu.com.cn/problem/P3870

​	https://www.luogu.com.cn/problem/P2184

​	区间加等差数列，单点查询：https://www.luogu.com.cn/problem/P1438

​	平均值和方差：https://www.luogu.com.cn/problem/P1471

## 线段树区间合并

​	一个信息加工不出来就用多个信息。

​	最经典的模型是连续1的最长子串长度。

​	需要维持信息：

​		1）最长子串长度；

​		2）最长前缀1的长度；

​		3）最长后缀1的长度。

​	模板题：https://www.luogu.com.cn/problem/P2572

### code

```cpp
#include <iostream>
#include <vector>
using namespace std;

#define MAXN 100005

typedef long long ll;

int n, m;
int a[MAXN];
int sum[MAXN << 2];
int len0[MAXN << 2];
int pre0[MAXN << 2];
int suf0[MAXN << 2];
int len1[MAXN << 2];
int pre1[MAXN << 2];
int suf1[MAXN << 2];
int change[MAXN << 2];
bool update[MAXN << 2];
bool rev[MAXN << 2];

void up(int i, int ln, int rn)
{
	int l = i << 1;
	int r = i << 1 | 1;
	sum[i] = sum[l] + sum[r];
	len0[i] = max(max(len0[l], len0[r]), suf0[l] + pre0[r]);
	pre0[i] = len0[l] < ln ? pre0[l] : (pre0[l] + pre0[r]);
	suf0[i] = len0[r] < rn ? suf0[r] : (suf0[l] + suf0[r]);
	len1[i] = max(max(len1[l], len1[r]), suf1[l] + pre1[r]);
	pre1[i] = len1[l] < ln ? pre1[l] : (pre1[l] + pre1[r]);
	suf1[i] = len1[r] < rn ? suf1[r] : (suf1[l] + suf1[r]);
}

void updatelazy(int i, int v, int n)
{
	sum[i] = v * n;
	len0[i] = pre0[i] = suf0[i] = v == 0 ? n : 0;
	len1[i] = pre1[i] = suf1[i] = v == 1 ? n : 0;
	change[i] = v;
	update[i] = true;
	rev[i] = false;
}

void revlazy(int i, int n)
{
	sum[i] = n - sum[i];
	int tmp;
	tmp = len0[i]; len0[i] = len1[i]; len1[i] = tmp;
	tmp = pre0[i]; pre0[i] = pre1[i]; pre1[i] = tmp;
	tmp = suf0[i]; suf0[i] = suf1[i]; suf1[i] = tmp;
	rev[i] = !rev[i];
}

void down(int i, int ln, int rn)
{
	if(update[i])
	{
		updatelazy(i << 1, change[i], ln);
		updatelazy(i << 1 | 1, change[i], rn);
		update[i] = false;
	}
	if(rev[i])
	{
		revlazy(i << 1, ln);
		revlazy(i << 1 | 1, rn);
		rev[i] = false;
	}
}

void build(int l, int r, int i)
{
	if(l == r)
	{
		sum[i] = a[l];
		pre0[i] = suf0[i] = len0[i] = a[l] == 0 ? 1 : 0;
		pre1[i] = suf1[i] = len1[i] = a[l] == 1 ? 1 : 0;
	}
	else
	{
		int mid = (l + r) >> 1;
		build(l, mid, i << 1);
		build(mid + 1, r, i << 1 | 1);
		up(i, mid - l + 1, r - mid);
	}
	update[i] = false;
	rev[i] = false;
}

void qjchange(int wl, int wr, int v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		updatelazy(i, v, r - l + 1);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(wl <= mid)
		{
			qjchange(wl, wr, v, l, mid, i << 1);
		}
		if(wr > mid)
		{
			qjchange(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i, mid - l + 1, r - mid);
	}
}

void qjrev(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		revlazy(i, r - l + 1);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(wl <= mid)
		{
			qjrev(wl, wr, l, mid, i << 1);
		}
		if(wr > mid)
		{
			qjrev(wl, wr, mid + 1, r, i << 1 | 1);
		}
		up(i, mid - l + 1, r - mid);
	}
}

int querysum(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return sum[i];
	}
	int mid = (l + r) >> 1;
	down(i, mid - l + 1, r - mid);
	int ans = 0;
	if(wl <= mid)
	{
		ans += querysum(wl, wr, l, mid, i << 1);
	}
	if(wr > mid)
	{
		ans += querysum(wl, wr, mid + 1, r, i << 1 | 1);
	}
	return ans;
}

vector<int> querylong(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return {len1[i], pre1[i], suf1[i]};
	}
	int mid = (l + r) >> 1;
	int ln = mid - l + 1;
	int rn = r - mid;
	down(i, ln, rn);
	if(wr <= mid)
	{
		return querylong(wl, wr, l, mid, i << 1);
	}
	if(wl > mid)
	{
		return querylong(wl, wr, mid + 1, r, i << 1 | 1);
	}
	vector<int> l3 = querylong(wl, wr, l, mid, i << 1);
	vector<int> r3 = querylong(wl, wr, mid + 1, r, i << 1 | 1);
	int llen = l3[0], lpre = l3[1], lsuf = l3[2];
	int rlen = r3[0], rpre = r3[1], rsuf = r3[2];
	int len = max(max(llen, rlen), lsuf + rpre);
	int pre = llen < mid - max(wl, l) + 1 ? lpre : (lpre + rpre);
	int suf = rlen < min(wr, r) - mid ? rsuf : (lsuf + rsuf);
	return {len, pre, suf};
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	build(1, n, 1);
	for(int i = 1, op, l, r; i <= m; i++)
	{
		cin >> op >> l >> r;
		l++, r++;
		if(op == 0)
		{
			qjchange(l, r, 0, 1, n, 1);
		}
		else if(op == 1)
		{
			qjchange(l, r, 1, 1, n, 1);
		}
		else if(op == 2)
		{
			qjrev(l, r, 1, n, 1);
		}
		else if(op == 3)
		{
			cout << querysum(l, r, 1, n, 1) << "\n";
		}
		else if(op == 4)
		{
			vector<int> ans = querylong(l, r, 1, n, 1);
			cout << ans[0] << "\n";
		}
	}


	return 0;
}
```

### 练习题目

​	https://www.luogu.com.cn/problem/P6492

​	https://www.luogu.com.cn/problem/P1503

​	https://www.luogu.com.cn/problem/P2894

## 开点线段树

​	开点线段树是一种面对数据量较大的情况。经典线段树n有一个范围，维护信息的数组开到4*n就够用了，但是面对一些n可以达到1e9甚至更高的情况，只要操作次数不是很大，就可以用开点线段树搏一搏，没错，就是搏一搏。因为大部分的都不是最优解，会有平衡树之类的算法正规解决，但是开点线段树只比经典线段树多了一点点的变化，易于理解，时间不充足时确实值得搏一下。

​	原理就是：面对大数据量，事先不准备这么大的空间，根结点编号为1，之后的所有节点都先不创建，只有访问到时才具体创建，通过一个cnt变量以及lc[i]表示i的左孩子的下标、rc[i]表示i的右孩子的下标即可。至于到底开多少空间呢？一般是比 树高 * 操作次数 * 2 这个数字大一些就可以了。

​	模板题：https://www.luogu.com.cn/problem/P2781

### code

```cpp
#include <iostream>
using namespace std;

#define MAXN 80005

typedef long long ll;

int n, m;
int lc[MAXN];
int rc[MAXN];
ll sum[MAXN];
ll add[MAXN];
int cnt = 1;

void up(int i, int l, int r)
{
	sum[i] = sum[l] + sum[r];
}

void lazy(int i, ll v, int n)
{
	sum[i] += v * n;
	add[i] += v;
}

void down(int i, int ln, int rn)
{
	if(add[i] != 0)
	{
		if(lc[i] == 0)
		{
			lc[i] = ++cnt;
		}
		if(rc[i] == 0)
		{
			rc[i] = ++cnt;
		}
		lazy(lc[i], add[i], ln);
		lazy(rc[i], add[i], rn);
		add[i] = 0;
	}
}

void qjadd(int wl, int wr, ll v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		lazy(i, v, r - l + 1);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(wl <= mid)
		{
			if(lc[i] == 0)
			{
				lc[i] = ++cnt;
			}
			qjadd(wl, wr, v, l, mid, lc[i]);
		}
		if(wr > mid)
		{
			if(rc[i] == 0)
			{
				rc[i] = ++cnt;
			}
			qjadd(wl, wr, v, mid + 1, r, rc[i]);
		}
		up(i, lc[i], rc[i]);
	}
}

ll query(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return sum[i];
	}
	int mid = (l + r) >> 1;
	down(i, mid - l + 1, r - mid);
	ll ans = 0;
	if(wl <= mid)
	{
		if(lc[i] != 0)
		{
			ans += query(wl, wr, l, mid, lc[i]);
		}
	}
	if(wr > mid)
	{
		if(rc[i] != 0)
		{
			ans += query(wl, wr, mid + 1, r, rc[i]);
		}
	}
	return ans;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> m;
	ll k;
	for(int i = 1, op, x, y; i <= m; i++)
	{
		cin >> op;
		if(op == 1)
		{
			cin >> x >> y >> k;
			qjadd(x, y, k, 1, n, 1);
		}
		else if(op == 2)
		{
			cin >> x >> y;
			cout << query(x, y, 1, n, 1) << "\n";
		}
	}	

	return 0;
}
```

### 练习题目

​	https://leetcode.cn/problems/count-integers-in-intervals/

## 区间最值操作（吉司机线段树）

​	模板题：https://acm.hdu.edu.cn/showproblem.php?pid=5306

​	*（注意：杭电OJ此题时间空间要求卡的都严，下面code给出的是采用更快的scanf和printf模式，这样才能通过）*

​	就是在原来的基础上修改了区间修改的部分，修改如下：l, r, x，在[l, r]上每个位置修改为 min(原值，x)。这样就需要势能分析+剪枝操作了。此题是高中集训队吉如一老师发明，故此线段树都叫做吉如一线段树。也叫吉司机线段树。

​	参考论文如下：https://github.com/algorithmzuo/algorithm-journey/blob/main/src/class114/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8E%86%E5%8F%B2%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98-%E5%90%89%E5%A6%82%E4%B8%80.pdf

​	维护信息如下：

​		1）sum区间累加和；

​		2）maxv区间最大值（同时作为懒信息）；

​		3）maxcnt区间最大值的个数；

​		4）secmax区间严格次大值，如果全为最大值，设置成一个足够小的值即可。

​	给定一组操作l, r, x，下面分析剪枝：

​		1）当[l, r]区间最大值maxv[i] <= x时，根本不需要修改；

​		2）当x满足：secmax[i] < x <= maxv[i]时，只需改变最大值为x，调整sum[i]，减去maxcnt * (maxv[i] - x)即可；

​		3）当x <= secmax时，就需要暴力下发任务了，此时需要势能分析。最好的情况无疑就是没有区间次大值，也就是所有值都一样。设置给所有节点标签，当该节点最大值不等于父结点的最大值时。随着任务到来，向下扎的过程中，该标签会被逐渐回收，随后就可以懒住了，再操作代价就非常低了。

### code

```cpp
#include <iostream>
#include <algorithm>
#include <limits.h>
using namespace std;

#define MAXN 1000005
#define LOWEST -1

typedef long long ll;

int n, m;

ll sum[MAXN << 2];
int maxv[MAXN << 2];
int sem[MAXN << 2];
int cnt[MAXN << 2];

void up(int i)
{
	int l = i << 1;
	int r = i << 1 | 1;
	sum[i] = sum[l] + sum[r];
	maxv[i] = max(maxv[l], maxv[r]);
	if(maxv[l] > maxv[r])
	{
		cnt[i] = cnt[l];
		sem[i] = max(sem[l], maxv[r]);
	}
	else if(maxv[l] < maxv[r])
	{
		cnt[i] = cnt[r];
		sem[i] = max(maxv[l], sem[r]);
	}
	else
	{
		cnt[i] = cnt[l] + cnt[r];
		sem[i] = max(sem[l], sem[r]);
	}
}

void lazy(int i, int v)
{
	if(v < maxv[i])
	{
		sum[i] -= ((ll)maxv[i] - v) * cnt[i];
		maxv[i] = v;
	}
}

void down(int i)
{
	lazy(i << 1, maxv[i]);
	lazy(i << 1 | 1, maxv[i]);
}

void build(int l, int r, int i)
{
	if(l == r)
	{
		int tmp;
		scanf("%d", &tmp);
		maxv[i] = sum[i] = tmp;
		cnt[i] = 1;
		sem[i] = LOWEST;
	}
	else
	{
		int mid = (l + r) >> 1;
		build(l, mid, i << 1);
		build(mid + 1, r, i << 1 | 1);
		up(i);
	}
}

void setmin(int wl, int wr, int v, int l, int r, int i)
{
	if(v >= maxv[i])
	{
		return ;
	}
	if(wl <= l && r <= wr && sem[i] < v)
	{
		lazy(i, v);
	}
	else
	{
		down(i);
		int mid = (l + r) >> 1;
		if(wl <= mid)
		{
			setmin(wl, wr, v, l, mid, i << 1);
		}
		if(wr > mid)
		{
			setmin(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}

int querymax(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return maxv[i];
	}
	down(i);
	int mid = (l + r) >> 1;
	int ans = INT_MIN;
	if(wl <= mid)
	{
		ans = max(ans, querymax(wl, wr, l, mid, i << 1));
	}
	if(wr > mid)
	{
		ans = max(ans, querymax(wl, wr, mid + 1, r, i << 1 | 1));
	}
	return ans;
}

ll querysum(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return sum[i];
	}
	down(i);
	int mid = (l + r) >> 1;
	ll ans = 0;
	if(wl <= mid)
	{
		ans += querysum(wl, wr, l, mid, i << 1);
	}
	if(wr > mid)
	{
		ans += querysum(wl, wr, mid + 1, r, i << 1 | 1);
	}
	return ans;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t;
	scanf("%d", &t);
	while(t--)
	{
		scanf("%d%d", &n, &m);
		build(1, n, 1);
		for(int i = 1, op, l, r, x; i <= m; i++)
		{
			scanf("%d", &op);
			if(op == 0)
			{
				scanf("%d%d%d", &l, &r, &x);
				setmin(l, r, x, 1, n, 1);
			}
			else if(op == 1)
			{
				scanf("%d%d", &l, &r);
				int ans = querymax(l, r, 1, n, 1);
				printf("%d\n", ans);
			}
			else if(op == 2)
			{
				scanf("%d%d", &l, &r);
				ll ans = querysum(l, r, 1, n, 1);
    			printf("%lld\n", ans);
			}
		}
	}

	return 0;
}
```

### 练习题目

​	在上述基础上增加一条操作：l, r, x，在[l, r]范围上每个数字增加x。

​	势能虽然增加，但是是logn的平方的规模，代价很小。

​	测试链接在下面的内容里，是与历史最值问题放在一起的模板题。

## 历史最值 && 区间最值操作

​	模板题：https://www.luogu.com.cn/problem/P6242

### code

```cpp
#include <iostream>
#include <algorithm>
#include <limits.h>
using namespace std;

#define MAXN 500005
#define LOWEST LONG_MIN

typedef long long ll;

int n, m;

int arr[MAXN];
ll sum[MAXN << 2];
ll maxv[MAXN << 2];
ll sem[MAXN << 2];
int cnt[MAXN << 2];
ll maxadd[MAXN << 2];
ll otheradd[MAXN << 2];
ll maxhistory[MAXN << 2];
ll maxaddtop[MAXN << 2];
ll otheraddtop[MAXN << 2];

void up(int i)
{
	int l = i << 1;
	int r = i << 1 | 1;
	maxhistory[i] = max(maxhistory[l], maxhistory[r]);
	sum[i] = sum[l] + sum[r];
	maxv[i] = max(maxv[l], maxv[r]);
	if(maxv[l] > maxv[r])
	{
		cnt[i] = cnt[l];
		sem[i] = max(sem[l], maxv[r]);
	}
	else if(maxv[l] < maxv[r])
	{
		cnt[i] = cnt[r];
		sem[i] = max(maxv[l], sem[r]);
	}
	else
	{
		cnt[i] = cnt[l] + cnt[r];
		sem[i] = max(sem[l], sem[r]);
	}
}

void lazy(int i, int n, ll maxaddv, ll otheraddv, ll maxupv, ll otherupv)
{
	maxhistory[i] = max(maxhistory[i], maxv[i] + maxupv);
	maxaddtop[i] = max(maxaddtop[i], maxadd[i] + maxupv);
	otheraddtop[i] = max(otheraddtop[i], otheradd[i] + otherupv);
	sum[i] += maxaddv * cnt[i] + otheraddv * (n - cnt[i]);
	maxv[i] += maxaddv;
	sem[i] += sem[i] == LOWEST ? 0 : otheraddv;
	maxadd[i] += maxaddv;
	otheradd[i] += otheraddv;
}

void down(int i, int ln, int rn)
{
	int l = i << 1;
	int r = i << 1 | 1;
	ll tmp = max(maxv[l], maxv[r]);
	if(maxv[l] == tmp)
	{
		lazy(l, ln, maxadd[i], otheradd[i], maxaddtop[i], otheraddtop[i]);
	}
	else
	{
		lazy(l, ln, otheradd[i], otheradd[i], otheraddtop[i], otheraddtop[i]);
	}
	if(maxv[r] == tmp)
	{
		lazy(r, rn, maxadd[i], otheradd[i], maxaddtop[i], otheraddtop[i]);
	}
	else
	{
		lazy(r, rn, otheradd[i], otheradd[i], otheraddtop[i], otheraddtop[i]);
	}
	maxadd[i] = otheradd[i] = maxaddtop[i] = otheraddtop[i] = 0;
}

void build(int l, int r, int i)
{
	if(l == r)
	{
		maxv[i] = sum[i] = maxhistory[i] = arr[l];
		cnt[i] = 1;
		sem[i] = LOWEST;
	}
	else
	{
		int mid = (l + r) >> 1;
		build(l, mid, i << 1);
		build(mid + 1, r, i << 1 | 1);
		up(i);
	}
	maxadd[i] = otheradd[i] = maxaddtop[i] = otheraddtop[i] = 0;
}

void qjadd(int wl, int wr, ll v, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		lazy(i, r - l + 1, v, v, v, v);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(wl <= mid)
		{
			qjadd(wl, wr, v, l, mid, i << 1);
		}
		if(wr > mid)
		{
			qjadd(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}

void setmin(int wl, int wr, ll v, int l, int r, int i)
{
	if(v >= maxv[i])
	{
		return ;
	}
	if(wl <= l && r <= wr && sem[i] < v)
	{
		lazy(i, r - l + 1, v - maxv[i], 0, v - maxv[i], 0);
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		if(wl <= mid)
		{
			setmin(wl, wr, v, l, mid, i << 1);
		}
		if(wr > mid)
		{
			setmin(wl, wr, v, mid + 1, r, i << 1 | 1);
		}
		up(i);
	}
}

ll querymax(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return maxv[i];
	}
	int mid = (l + r) >> 1;
	down(i, mid - l + 1, r - mid);
	ll ans = LONG_MIN;
	if(wl <= mid)
	{
		ans = max(ans, querymax(wl, wr, l, mid, i << 1));
	}
	if(wr > mid)
	{
		ans = max(ans, querymax(wl, wr, mid + 1, r, i << 1 | 1));
	}
	return ans;
}

ll querysum(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return sum[i];
	}
	int mid = (l + r) >> 1;
	down(i, mid - l + 1, r - mid);
	ll ans = 0;
	if(wl <= mid)
	{
		ans += querysum(wl, wr, l, mid, i << 1);
	}
	if(wr > mid)
	{
		ans += querysum(wl, wr, mid + 1, r, i << 1 | 1);
	}
	return ans;
}

ll queryhistorymax(int wl, int wr, int l, int r, int i)
{
	if(wl <= l && r <= wr)
	{
		return maxhistory[i];
	}
	else
	{
		int mid = (l + r) >> 1;
		down(i, mid - l + 1, r - mid);
		ll ans = LONG_MIN;
		if(wl <= mid)
		{
			ans = max(ans, queryhistorymax(wl, wr, l, mid, i << 1));
		}
		if(wr > mid)
		{
			ans = max(ans, queryhistorymax(wl, wr, mid + 1, r, i << 1 | 1));
		}
		return ans;
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> arr[i];
	}
	build(1, n, 1);
	ll x, k;
	for(int i = 1, op, l, r; i <= m; i++)
	{
		cin >> op;
		if(op == 1)
		{
			cin >> l >> r >> k;
			qjadd(l, r, k, 1, n, 1);
		}
		else if(op == 2)
		{
			cin >> l >> r >> x;
			setmin(l, r, x, 1, n, 1);
		}
		else if(op == 3)
		{
			cin >> l >> r;
    		cout << querysum(l, r, 1, n, 1) << "\n";
		}
		else if(op == 4)
		{
			cin >> l >> r;
			cout << querymax(l, r, 1, n, 1) << "\n";
		}
		else if(op == 5)
		{
			cin >> l >> r;
			cout << queryhistorymax(l, r, 1, n, 1) << "\n";
		}
	}

	return 0;
}
```

## 扫描线和线段树

​	

## 摩尔投票系列问题

​	经典摩尔投票问题：https://leetcode.cn/problems/majority-element/

​	
