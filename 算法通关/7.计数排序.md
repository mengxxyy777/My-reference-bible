# 计数排序

​	这是我们第一个学习的非比较排序，非比较型的排序都会用到“桶”的概念。等学完这节课，相信会对桶有一定的认知。

## 何为计数排序？

​	计数排序是遍历数组，统计每个数字分别出现多少次，然后再逐一从小到大回收。这里采用哈希表计数，其实就是所谓的桶。

## 计数排序过程

​	给定一个长度为6的数组，下标从0开始：[1, 4, 1, 3, 5, 2]。

​		准备一个哈希表cnt，统计每个数字出现的次数，如图所示：

![image-20241013161032066](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20241013161032066.png)

​		然后我们从1开始收集，并放回原数组：[1, 1, 2, 3, 4, 5]。得到的有序数组。

​		code也非常简单。

## code

```cpp
#include <iostream>
#include <map>
using namespace std;

int n;
int a[105];
int index;

void countsort()
{
	map<int, int> cnt;
	for (int i = 0; i < n; i++)
	{
		cnt[a[i]]++;
	}
	for (int i = -10005; i < 10005; i++)
	{
		while (cnt[i])
		{
			a[index++] = i;
			cnt[i]--;
		}
	}
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}

	countsort();

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	假设数字最大值为k，**时间复杂度为O(n+k)**。

### 	空间复杂度

​	需要一个桶，大小为最大数字，**空间复杂度为O(k)**。

## 小结

### 	稳定性

​	对于每个桶，先进来的数字先出去，所以相同数字的相对位置不会被改变。

### 	非原地排序

​	需要k个桶用来“分配”和是“收集”。

### 	优点

​	简单易实现，在众多算法中效率最高，适用于数据范围较小的情况。

### 	缺点

​	依赖于数据范围，并且需要额外空间。