# 归并排序

​	归并排序是学习的第一个时间复杂度为O(nlogn)的排序算法，也是比较简单的入门算法。

## 何为归并排序？

​	归并排序采用的是典型的**分而治之**的思想，归，即为递归，并，即为合并。递归到最底层之后，一步一步向上合并，使得合并后的数组有序，从而最终使得数组有序。

## 归并排序过程

​	给出一个长度为6的数组，下标从0开始：[1, 4, 6, 3, 5, 2]。

​		先把数组对半分割，变成：[1, 4, 6]、[3, 5, 2]两部分。

​		对于每个部分，继续对半分割：[1, 4]、 [6]、[3, 5]、[2]。

​		这个时候第二个数组和第四个数组只剩下一个元素，一个元素当然就是有序的了，直接返回就可以，继续分割长度为2的两个数组。

​		[1]、[4]、[6]、[3]、[5]、[2]，这个时候递归已经到了最深层，接下来返回，返回的过程中合并成有序数组：

​		[1, 4]、[6]、[3, 5]、[2]，看起来没什么变化，继续返回。

​		[1, 4, 6]、[2, 3, 5]，这回明显了，两个数组分别有序。

​		[1, 2, 3, 4, 5, 6]，这便是最终结果。

​	但是注意：递归的过程并不是上述的样子，而是逐层深入返回再深入的！！！

​	代码其实比较好写，向下分解的过程递归自动实现好了，主要是合并。

## code

```cpp
#include <iostream>
using namespace std;

int a[105];
int help[105];

// 合并过程 
void merge(int l, int r)
{
	// 找到中点 
	int mid = (l+r) >> 1;
	int i = l; // i用来赋值 
	int left = l; // 记录第一个数组的左边界下标 
	int right = mid+1; // 记录第二个数组的左边界下标 
	// 两个数组下标位置都有数字时 
	while(left <= mid && right <= r)
	{
		help[i++] = a[left] <= a[right] ? a[left++] : a[right++];
	}
	// 左边数组还有数字 
	while(left <= mid)
	{
		help[i++] = a[left++];
	}
	// 右边数组还有数字 
	while(right <= r)
	{
		help[i++] = a[right++];
	}
	// 将排好序的数组copy到原数组即可 
	for(i = l; i <= r; i++)
	{
		a[i] = help[i];
	}
}

// 对下标[l, r]进行归并排序 
void mergeSort(int l, int r)
{
	if(l == r)
	{
		return ;
	}
	
	int mid = (l+r) >> 1; 
	mergeSort(l, mid); // 左半部分归并排序 
	mergeSort(mid+1, r); // 右半部分归并排序 
	
	merge(l, r); // 合并成有序数组 
}

int main()
{
	int n;
	cin >> n;
	for(int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	mergeSort(0, n-1);
	
	for(int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}
	
	return 0;
} 
```



## 递归过程改为非递归过程

​	本质上是一样的，只不过我们循环处理这个合并的过程。那么下放的过程呢？我们就不用递归了，改用一个变量记录每次的步长，这个步长就是每次合并数组的规模，从1开始，到大于等于数组长度为止。

## 归并排序过程（非递归版）

​	还是那个数组：[1, 4, 6, 3, 5, 2]。

​	首先设置步长为1，实际上就相当于每两个元素进行排序合并：[1, 4]、[3, 6]、[2, 5]。

​	步长为2，右半部分如果没有元素就不处理：[1, 3, 4, 6]、[2, 5]。

​	步长为4，右半部分有两个元素，只要右半部分有一个元素，就正常合并：[1, 2, 3, 4, 5, 6]。

​	排序完成，代码需要注意步长的问题以及边界的处理。

## code

```cpp
#include <iostream>
using namespace std;

int n;
int a[105];
int help[105];

// 合并过程 
void merge(int l, int m, int r)
{
	int i = l; // i用来赋值 
	int left = l; // 记录第一个数组的左边界下标 
	int right = m + 1; // 记录第二个数组的左边界下标 
	// 两个数组下标位置都有数字时 
	while (left <= m && right <= r)
	{
		help[i++] = a[left] <= a[right] ? a[left++] : a[right++];
	}
	// 左边数组还有数字 
	while (left <= m)
	{
		help[i++] = a[left++];
	}
	// 右边数组还有数字 
	while (right <= r)
	{
		help[i++] = a[right++];
	}
	// 将排好序的数组copy到原数组即可 
	for (i = l; i <= r; i++)
	{
		a[i] = help[i];
	}
}

void mergeSort()
{
	// 步长从一开始翻倍 
	for (int step = 1; step < n; step <<= 1)
	{
		// 左边界 
		int left = 0;
		while (left < n)
		{
			int m = left + step - 1;
			if (m + 1 >= n)
			{
				break;
			}
			int right = min(left + (step << 1) - 1, n - 1); // 防止越出数组的最后一个位置 
			merge(left, m, right); // 注意此时传入的m
			left = right + 1; // 下一个左边界是本次有边界的下一个位置 
		}
	}
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}

	mergeSort();

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```



## 时间复杂度&&空间复杂度

### 	时间复杂度

​	递归版本套用master公式可知，T(n) = 2*T(n/2) + O(n)。此时log(b, a) == c，**时间复杂度为O(nlogn)**。

​	非递归版轻易可知。

### 	空间复杂度

​	需要额外的help辅助数组，大小同原数组，因此**空间复杂度为O(n)**。

## 小结

### 非原地排序

​	需要辅助数组。

### 稳定性

​	当两个数字相同时，左边先拷贝，没有改变相对位置，因此具有稳定性。

### 优点

​	可拓展，可以很容易扩展到并行计算中

### 缺点

​	需要额外的辅助空间，并且实现代码较为困难，相比于其他入门排序算法。

