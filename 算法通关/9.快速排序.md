# 快速排序

​	快速排序是一种平均时间复杂度可以维持在O(n*logn)的排序算法，在众多排序算法中性能比较优异。

## 何为快速排序？

​	快速排序需要先选择数组中的随机一个数作为基准，然后所有比基准值小的都放在基准位置左边，所有比基准位置大的都放在基准位置右边，再递归地在左边和右边进行快速排序，最终得到的就是一个有序的数组。

## 快速排序过程

​	给定一个长度为6的数组，下标从0开始：[1, 4, 6, 3, 5, 2]。

​		首先，随机选择一个数字3，第一次排序结束后：[1, 2, 3, 4, 6, 5]。（*这里不一定准确*）

​		然后左半部分[1, 2]进行快排，随机选择一个数字1，排好序状态不变。

​		右半部分[4, 6, 5]快排，随机选择一个数字5，结果：[4, 5, 6]。

​		这个时候还需要递归深入[4]以及[6]进行快排，只有一个数字的情况就是递归边界，返回即可。

​		整体返回后，数组就有序了。

​	代码需要抠一抠细节。

## code

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int n;
int a[105];

// 分组函数，返回值是此次确定好位置的下标
// 并且将小于基准值的所有元素移动到该位置左边，大于基准值的所有元素移动到该位置右边 
int partition(int l, int r)
{
	// 在[l, r]上随机生成一个下标 
	int randomIndex = l + rand() % (r - l + 1);
	int x = a[randomIndex];

	int k = l;
	int temp = 0; // 记录一个基准值下标，最后要把这个数字放在分界点左侧 
	for (int i = l; i <= r; i++)
	{
		if (a[i] <= x)
		{
			// 找到小的就换到左边 
			swap(a[k], a[i]);
			if (a[k] == x)
			{
				temp = k;
			}
			k++;
		}
	}
	
	// 把基准值放在分界点左侧 
	swap(a[temp], a[k - 1]);
	return k - 1;
}

// 对[l, r]下标的数字快速排序 
void quickSort(int l, int r)
{
	if (l >= r)
	{
		return;
	}
	
	// 找到分界点 
	int mid = partition(l, r);
	 
	quickSort(l, mid - 1); // 左侧快排 
	quickSort(mid + 1, r); // 右侧快排 
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	// 这句话是生成随机种子，记住就好啦 
	srand(static_cast<unsigned int>(time(NULL)));

	quickSort(0, n - 1);

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```

## 荷兰国旗问题优化partition函数

​	核心优化点在于partition函数，上面的版本每次只确定一个基准值的位置，对于多个基准值就需要调用多次，有没有什么办法一次就能搞定所有基准值的情况呢？换句话说，在partition划分时，原来是<=x，以及>x，现在要划分<x，==x，>x三部分，其中==x的部分不管有几个数字，都在这一次确定好，返回左侧区域最大下标和右侧区域最大下标，做好下次递归的区域划分即可。

​	为什么叫荷兰国旗问题优化呢？因为我们分出的三个区域，就像荷兰国旗一样红白蓝三个区域，只不过方向好像不太对。。。

​	这里的代码仍然需要抠一抠细节。

## code（partition优化版）

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int n;
int a[105];

// 分组函数，返回值是此次确定好位置的下标
// 并且将小于基准值的所有元素移动到该位置左边，大于基准值的所有元素移动到该位置右边 
pair<int, int> partition(int l, int r)
{
	// 在[l, r]上随机生成一个下标 
	int randomIndex = l + rand() % (r - l + 1);
	int x = a[randomIndex];
	
	int i = l;
	int left = l;
	int right = r;
	
	// 一直处理到i大于右侧区域 
	while(i <= right)
	{
		if(a[i] < x)
		{
			swap(a[left++], a[i++]);
		}
		else if(a[i] == x)
		{
			i++;
		}
		else if(a[i] > x)
		{
			swap(a[right--], a[i]);
		}
	}
	
	return {left, right};
}

// 对[l, r]下标的数字快速排序 
void quickSort(int l, int r)
{
	if (l >= r)
	{
		return;
	}
	
	// 找到分界点 
	
	pair<int, int> mid = partition(l, r);
	int left = mid.first;
	int right = mid.second;
	 
	quickSort(l, left - 1); // 左侧快排 
	quickSort(right + 1, r); // 右侧快排 
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	
	// 这句话是生成随机种子，记住就好啦 
	srand(static_cast<unsigned int>(time(NULL)));

	quickSort(0, n - 1);

	for (int i = 0; i < n; i++)
	{
		cout << a[i] << " ";
	}

	return 0;
}
```

​	优化点：相同的数字每次都能确定好位置。

## 时间复杂度&&空间复杂度

### 	时间复杂度

​	最差情况：数组有序，基准值每次都从一边选，O(n^2)；

​	最好情况：每次基准值选择中点，O(n*logn)。

### 	空间复杂度

​	最差情况：二叉树退化成链表，递归调用n层，O(n)；

​	最好情况：完全二叉树，递归调用logn层，O(logn)。

​	采用随机选择基准值的方法，可以将快速排序的时间复杂度稳定在O(n*logn)，空间复杂度稳定在O(logn)。证明略。

## 小结

### 	不稳定性

​	算法具有频繁交换的操作，使得排序不具有稳定性。

### 	原地排序

​	不需要额外的辅助数组（这里不用管递归调用的系统栈）。

### 	优点

​	高效：采用随机选择基准值的办法，能让快排在各种情况下表现较为优异。

​	原地排序：不浪费额外空间。

### 	缺点

​	不稳定性
